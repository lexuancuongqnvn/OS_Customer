/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { CookieService } from "ngx-cookie";
import { AppSession } from "../app-session/app-session";
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export class ApiBase {
    authToken = '';
    protected constructor(
        private appSession: AppSession
    ) {

    }
    setAuthToken(token: string) {
        this.authToken = token;
    }
    setDataUpload(d: any) {
        dataUploads.push(d);
    }
    deleteDataUpload_ById(id: any) {
        for (var i = 0; i < dataUploads.length; i++)
            if (dataUploads[i]['id'] == id) {
                dataUploads.splice(i, 0);
                break;
            }
    }
    clearAllDataUpload() {
        dataUploads = [];
    }
    get getDataUpload(): any {
        return dataUploads;
    }
    protected transformOptions(options: any): Promise<any> {
        // options.headers = options.headers.append('Authorization', `${this.authToken}`);
        if(this.appSession.user)
            options.headers = options.headers.append('Authorization', this.appSession.user.token);
        return Promise.resolve(options);
    }
}

@Injectable()
export class AccountService extends ApiBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppSession) configuration: AppSession, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param uSER_NAME (optional) 
     * @param pASSWORD (optional) 
     * @return Success
     */
    sYS_Account_Infomation_CheckLogin(uSER_NAME: string | null | undefined, pASSWORD: string | null | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Account/SYS_Account_Infomation_CheckLogin?";
        if (uSER_NAME !== undefined && uSER_NAME !== null)
            url_ += "USER_NAME=" + encodeURIComponent("" + uSER_NAME) + "&";
        if (pASSWORD !== undefined && pASSWORD !== null)
            url_ += "PASSWORD=" + encodeURIComponent("" + pASSWORD) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_Account_Infomation_CheckLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_Account_Infomation_CheckLogin(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_Account_Infomation_CheckLogin(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sYS_Account_Search(body: SYS_Account_Group | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Account/SYS_Account_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_Account_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_Account_Search(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_Account_Search(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param username (optional) 
     * @return Success
     */
    sYS_Account_Info_Search_byUser(username: string | null | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Account/SYS_Account_Info_Search_byUser?";
        if (username !== undefined && username !== null)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_Account_Info_Search_byUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_Account_Info_Search_byUser(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_Account_Info_Search_byUser(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param email (optional) 
     * @param code (optional) 
     * @param passwordNew (optional) 
     * @param passwordNew_Confirm (optional) 
     * @return Success
     */
    sYS_Account_Infomation_UpdatePassword(email: string | null | undefined, code: number | undefined, passwordNew: string | null | undefined, passwordNew_Confirm: string | null | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Account/SYS_Account_Infomation_UpdatePassword?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (passwordNew !== undefined && passwordNew !== null)
            url_ += "passwordNew=" + encodeURIComponent("" + passwordNew) + "&";
        if (passwordNew_Confirm !== undefined && passwordNew_Confirm !== null)
            url_ += "passwordNew_Confirm=" + encodeURIComponent("" + passwordNew_Confirm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_Account_Infomation_UpdatePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_Account_Infomation_UpdatePassword(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_Account_Infomation_UpdatePassword(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sYS_Account_Infomation_Update(body: SYS_Account_Infomation | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Account/SYS_Account_Infomation_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_Account_Infomation_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_Account_Infomation_Update(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_Account_Infomation_Update(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param username (optional) 
     * @return Success
     */
    requestManagement_Search(username: string | null | undefined): Observable<RequestManagement_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Account/RequestManagement_Search?";
        if (username !== undefined && username !== null)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRequestManagement_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestManagement_Search(<any>response_);
                } catch (e) {
                    return <Observable<RequestManagement_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestManagement_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processRequestManagement_Search(response: HttpResponseBase): Observable<RequestManagement_ENTITY[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RequestManagement_ENTITY.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestManagement_ENTITY[]>(<any>null);
    }

    /**
     * @param username (optional) 
     * @return Success
     */
    requestManagement_History(username: string | null | undefined): Observable<RequestManagement_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Account/RequestManagement_History?";
        if (username !== undefined && username !== null)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRequestManagement_History(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestManagement_History(<any>response_);
                } catch (e) {
                    return <Observable<RequestManagement_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestManagement_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processRequestManagement_History(response: HttpResponseBase): Observable<RequestManagement_ENTITY[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RequestManagement_ENTITY.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestManagement_ENTITY[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sYS_Account_Infomation_ForgotPassword_Inserst(body: Mail_ENTITY | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Account/SYS_Account_Infomation_ForgotPassword_Inserst";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_Account_Infomation_ForgotPassword_Inserst(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_Account_Infomation_ForgotPassword_Inserst(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_Account_Infomation_ForgotPassword_Inserst(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }
}

@Injectable()
export class AcctionService extends ApiBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppSession) configuration: AppSession, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userID (optional) 
     * @param tABLE_NAME (optional) 
     * @return Success
     */
    acction_Search_byTableName(userID: number | undefined, tABLE_NAME: string | null | undefined): Observable<SYS_ActionsOnTable_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Acction/Acction_Search_byTableName?";
        if (userID === null)
            throw new Error("The parameter 'userID' cannot be null.");
        else if (userID !== undefined)
            url_ += "userID=" + encodeURIComponent("" + userID) + "&";
        if (tABLE_NAME !== undefined && tABLE_NAME !== null)
            url_ += "TABLE_NAME=" + encodeURIComponent("" + tABLE_NAME) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAcction_Search_byTableName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcction_Search_byTableName(<any>response_);
                } catch (e) {
                    return <Observable<SYS_ActionsOnTable_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SYS_ActionsOnTable_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processAcction_Search_byTableName(response: HttpResponseBase): Observable<SYS_ActionsOnTable_ENTITY[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SYS_ActionsOnTable_ENTITY.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SYS_ActionsOnTable_ENTITY[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acction_Search(body: SYS_ActionsOnTable_ENTITY | undefined): Observable<SYS_ActionsOnTable_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Acction/Acction_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAcction_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcction_Search(<any>response_);
                } catch (e) {
                    return <Observable<SYS_ActionsOnTable_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SYS_ActionsOnTable_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processAcction_Search(response: HttpResponseBase): Observable<SYS_ActionsOnTable_ENTITY[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SYS_ActionsOnTable_ENTITY.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SYS_ActionsOnTable_ENTITY[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    acction_Delete_ListID(input: string[] | null | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Acction/Acction_Delete_ListID?";
        if (input !== undefined && input !== null)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAcction_Delete_ListID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcction_Delete_ListID(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processAcction_Delete_ListID(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acction_Update(body: SYS_ActionsOnTable_ENTITY[] | null | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Acction/Acction_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAcction_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcction_Update(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processAcction_Update(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }
}

@Injectable()
export class EmployeeService extends ApiBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppSession) configuration: AppSession, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    employee_Positions_Search(body: Employee_Positions_ENTITY | undefined): Observable<Employee_Positions_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Employee/Employee_Positions_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processEmployee_Positions_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployee_Positions_Search(<any>response_);
                } catch (e) {
                    return <Observable<Employee_Positions_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Employee_Positions_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processEmployee_Positions_Search(response: HttpResponseBase): Observable<Employee_Positions_ENTITY[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Employee_Positions_ENTITY.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Employee_Positions_ENTITY[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hRM_Employee_Search(body: HRM_Employee_ENTITY | undefined): Observable<HRM_Employee_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Employee/HRM_Employee_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_Employee_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_Employee_Search(<any>response_);
                } catch (e) {
                    return <Observable<HRM_Employee_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HRM_Employee_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_Employee_Search(response: HttpResponseBase): Observable<HRM_Employee_ENTITY[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HRM_Employee_ENTITY.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HRM_Employee_ENTITY[]>(<any>null);
    }
}

@Injectable()
export class FileManagerService extends ApiBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppSession) configuration: AppSession, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param myFile (optional) 
     * @param insertFile (optional) 
     * @param altText (optional) 
     * @param message (optional) 
     * @param status (optional) 
     * @param type (optional) 
     * @param listFiles (optional) 
     * @param file_List (optional) 
     * @param description (optional) 
     * @param tbName (optional) 
     * @param colName (optional) 
     * @param stored (optional) 
     * @param id (optional) 
     * @param path (optional) 
     * @param size (optional) 
     * @param ref_MasterID (optional) 
     * @param ref_master_code (optional) 
     * @return Success
     */
    postFile(myFile: FileParameter[] | null | undefined, insertFile: InsertFile[] | null | undefined, altText: string | null | undefined, message: string | null | undefined, status: number | null | undefined, type: number | null | undefined, listFiles: string[] | null | undefined, file_List: File_ENTITY[] | null | undefined, description: string | null | undefined, tbName: string | null | undefined, colName: string | null | undefined, stored: string | null | undefined, id: number | undefined, path: string | null | undefined, size: number | null | undefined, ref_MasterID: number | null | undefined, ref_master_code: string | null | undefined): Observable<FileRecord> {
        let url_ = this.baseUrl + "/api/FileManager/PostFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (myFile !== null && myFile !== undefined)
            myFile.forEach(item_ => content_.append("MyFile", item_.data, item_.fileName ? item_.fileName : "MyFile") );
        if (insertFile !== null && insertFile !== undefined)
            insertFile.forEach(item_ => content_.append("insertFile", item_.toString()));
        if (altText !== null && altText !== undefined)
            content_.append("AltText", altText.toString());
        if (message !== null && message !== undefined)
            content_.append("Message", message.toString());
        if (status !== null && status !== undefined)
            content_.append("Status", status.toString());
        if (type !== null && type !== undefined)
            content_.append("Type", type.toString());
        if (listFiles !== null && listFiles !== undefined)
            listFiles.forEach(item_ => content_.append("listFiles", item_.toString()));
        if (file_List !== null && file_List !== undefined)
            file_List.forEach(item_ => content_.append("File_List", item_.toString()));
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (tbName !== null && tbName !== undefined)
            content_.append("tbName", tbName.toString());
        if (colName !== null && colName !== undefined)
            content_.append("colName", colName.toString());
        if (stored !== null && stored !== undefined)
            content_.append("stored", stored.toString());
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (path !== null && path !== undefined)
            content_.append("Path", path.toString());
        if (size !== null && size !== undefined)
            content_.append("Size", size.toString());
        if (ref_MasterID !== null && ref_MasterID !== undefined)
            content_.append("Ref_MasterID", ref_MasterID.toString());
        if (ref_master_code !== null && ref_master_code !== undefined)
            content_.append("ref_master_code", ref_master_code.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostFile(<any>response_);
                } catch (e) {
                    return <Observable<FileRecord>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileRecord>><any>_observableThrow(response_);
        }));
    }

    protected processPostFile(response: HttpResponseBase): Observable<FileRecord> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileRecord.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileRecord>(<any>null);
    }

    /**
     * @param myFile (optional) 
     * @param insertFile (optional) 
     * @param altText (optional) 
     * @param message (optional) 
     * @param status (optional) 
     * @param type (optional) 
     * @param listFiles (optional) 
     * @param file_List (optional) 
     * @param description (optional) 
     * @param tbName (optional) 
     * @param colName (optional) 
     * @param stored (optional) 
     * @param id (optional) 
     * @param path (optional) 
     * @param size (optional) 
     * @param ref_MasterID (optional) 
     * @param ref_master_code (optional) 
     * @return Success
     */
    postFile_v2(myFile: FileParameter[] | null | undefined, insertFile: InsertFile[] | null | undefined, altText: string | null | undefined, message: string | null | undefined, status: number | null | undefined, type: number | null | undefined, listFiles: string[] | null | undefined, file_List: File_ENTITY[] | null | undefined, description: string | null | undefined, tbName: string | null | undefined, colName: string | null | undefined, stored: string | null | undefined, id: number | undefined, path: string | null | undefined, size: number | null | undefined, ref_MasterID: number | null | undefined, ref_master_code: string | null | undefined): Observable<FileRecord> {
        let url_ = this.baseUrl + "/api/FileManager/PostFile_v2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (myFile !== null && myFile !== undefined)
            myFile.forEach(item_ => content_.append("MyFile", item_.data, item_.fileName ? item_.fileName : "MyFile") );
        if (insertFile !== null && insertFile !== undefined)
            insertFile.forEach(item_ => content_.append("insertFile", item_.toString()));
        if (altText !== null && altText !== undefined)
            content_.append("AltText", altText.toString());
        if (message !== null && message !== undefined)
            content_.append("Message", message.toString());
        if (status !== null && status !== undefined)
            content_.append("Status", status.toString());
        if (type !== null && type !== undefined)
            content_.append("Type", type.toString());
        if (listFiles !== null && listFiles !== undefined)
            listFiles.forEach(item_ => content_.append("listFiles", item_.toString()));
        if (file_List !== null && file_List !== undefined)
            file_List.forEach(item_ => content_.append("File_List", item_.toString()));
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (tbName !== null && tbName !== undefined)
            content_.append("tbName", tbName.toString());
        if (colName !== null && colName !== undefined)
            content_.append("colName", colName.toString());
        if (stored !== null && stored !== undefined)
            content_.append("stored", stored.toString());
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (path !== null && path !== undefined)
            content_.append("Path", path.toString());
        if (size !== null && size !== undefined)
            content_.append("Size", size.toString());
        if (ref_MasterID !== null && ref_MasterID !== undefined)
            content_.append("Ref_MasterID", ref_MasterID.toString());
        if (ref_master_code !== null && ref_master_code !== undefined)
            content_.append("ref_master_code", ref_master_code.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostFile_v2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostFile_v2(<any>response_);
                } catch (e) {
                    return <Observable<FileRecord>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileRecord>><any>_observableThrow(response_);
        }));
    }

    protected processPostFile_v2(response: HttpResponseBase): Observable<FileRecord> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileRecord.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileRecord>(<any>null);
    }
}

@Injectable()
export class GenRowTableService extends ApiBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppSession) configuration: AppSession, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sYS_GenRowTable_Search(body: SYS_GenRowTable | undefined): Observable<SYS_GenRowTable[]> {
        let url_ = this.baseUrl + "/api/GenRowTable/SYS_GenRowTable_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_GenRowTable_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_GenRowTable_Search(<any>response_);
                } catch (e) {
                    return <Observable<SYS_GenRowTable[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SYS_GenRowTable[]>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_GenRowTable_Search(response: HttpResponseBase): Observable<SYS_GenRowTable[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SYS_GenRowTable.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SYS_GenRowTable[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sYS_GenRowTable_Detail_Search(body: SYS_GenRowTable_Detail | undefined): Observable<SYS_GenRowTable_Detail[]> {
        let url_ = this.baseUrl + "/api/GenRowTable/SYS_GenRowTable_Detail_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_GenRowTable_Detail_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_GenRowTable_Detail_Search(<any>response_);
                } catch (e) {
                    return <Observable<SYS_GenRowTable_Detail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SYS_GenRowTable_Detail[]>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_GenRowTable_Detail_Search(response: HttpResponseBase): Observable<SYS_GenRowTable_Detail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SYS_GenRowTable_Detail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SYS_GenRowTable_Detail[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sYS_GenRowTable_Root_Search(body: SYS_GenRowTable | undefined): Observable<SYS_GenRowTable[]> {
        let url_ = this.baseUrl + "/api/GenRowTable/SYS_GenRowTable_Root_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_GenRowTable_Root_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_GenRowTable_Root_Search(<any>response_);
                } catch (e) {
                    return <Observable<SYS_GenRowTable[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SYS_GenRowTable[]>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_GenRowTable_Root_Search(response: HttpResponseBase): Observable<SYS_GenRowTable[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SYS_GenRowTable.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SYS_GenRowTable[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sYS_GenRowTable_Detail_Root_Search(body: SYS_GenRowTable_Detail | undefined): Observable<SYS_GenRowTable_Detail[]> {
        let url_ = this.baseUrl + "/api/GenRowTable/SYS_GenRowTable_Detail_Root_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_GenRowTable_Detail_Root_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_GenRowTable_Detail_Root_Search(<any>response_);
                } catch (e) {
                    return <Observable<SYS_GenRowTable_Detail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SYS_GenRowTable_Detail[]>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_GenRowTable_Detail_Root_Search(response: HttpResponseBase): Observable<SYS_GenRowTable_Detail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SYS_GenRowTable_Detail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SYS_GenRowTable_Detail[]>(<any>null);
    }

    /**
     * @return Success
     */
    sYS_GenRowTable_Opption_Search(): Observable<SYS_GenRowTable[]> {
        let url_ = this.baseUrl + "/api/GenRowTable/SYS_GenRowTable_Opption_Search";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_GenRowTable_Opption_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_GenRowTable_Opption_Search(<any>response_);
                } catch (e) {
                    return <Observable<SYS_GenRowTable[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SYS_GenRowTable[]>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_GenRowTable_Opption_Search(response: HttpResponseBase): Observable<SYS_GenRowTable[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SYS_GenRowTable.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SYS_GenRowTable[]>(<any>null);
    }

    /**
     * @param listId (optional) 
     * @return Success
     */
    sYS_GenRowTable_Delete_ListID(listId: string[] | null | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/GenRowTable/SYS_GenRowTable_Delete_ListID?";
        if (listId !== undefined && listId !== null)
            listId && listId.forEach(item => { url_ += "listId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_GenRowTable_Delete_ListID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_GenRowTable_Delete_ListID(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_GenRowTable_Delete_ListID(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sYS_GenRowTable_Update(body: SYS_GenRowTable[] | null | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/GenRowTable/SYS_GenRowTable_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_GenRowTable_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_GenRowTable_Update(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_GenRowTable_Update(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sYS_GenRowTable_Update_Detail(body: SYS_GenRowTable | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/GenRowTable/SYS_GenRowTable_Update_Detail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_GenRowTable_Update_Detail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_GenRowTable_Update_Detail(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_GenRowTable_Update_Detail(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }
}

@Injectable()
export class HRM_BranchService extends ApiBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppSession) configuration: AppSession, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hRM_Branch_Search(body: HRM_Branch_ENTITY | undefined): Observable<HRM_Branch_ENTITY[]> {
        let url_ = this.baseUrl + "/api/HRM_Branch/HRM_Branch_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_Branch_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_Branch_Search(<any>response_);
                } catch (e) {
                    return <Observable<HRM_Branch_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HRM_Branch_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_Branch_Search(response: HttpResponseBase): Observable<HRM_Branch_ENTITY[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HRM_Branch_ENTITY.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HRM_Branch_ENTITY[]>(<any>null);
    }
}

@Injectable()
export class HRM_WorkingTimeService extends ApiBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppSession) configuration: AppSession, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hRM_WorkingTime_Search(body: HRM_WorkingTime_ENTITY | undefined): Observable<HRM_WorkingTime_ENTITY[]> {
        let url_ = this.baseUrl + "/api/HRM_WorkingTime/HRM_WorkingTime_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_WorkingTime_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_WorkingTime_Search(<any>response_);
                } catch (e) {
                    return <Observable<HRM_WorkingTime_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HRM_WorkingTime_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_WorkingTime_Search(response: HttpResponseBase): Observable<HRM_WorkingTime_ENTITY[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HRM_WorkingTime_ENTITY.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HRM_WorkingTime_ENTITY[]>(<any>null);
    }
}

@Injectable()
export class MenuService extends ApiBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppSession) configuration: AppSession, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sYS_Menu_Search(body: SYS_Menu | undefined): Observable<SYS_Menu[]> {
        let url_ = this.baseUrl + "/api/Menu/SYS_Menu_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_Menu_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_Menu_Search(<any>response_);
                } catch (e) {
                    return <Observable<SYS_Menu[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SYS_Menu[]>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_Menu_Search(response: HttpResponseBase): Observable<SYS_Menu[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SYS_Menu.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SYS_Menu[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sYS_Menu_Detail_Search(body: SYS_Menu_Sub | undefined): Observable<SYS_Menu_Sub[]> {
        let url_ = this.baseUrl + "/api/Menu/SYS_Menu_Detail_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_Menu_Detail_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_Menu_Detail_Search(<any>response_);
                } catch (e) {
                    return <Observable<SYS_Menu_Sub[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SYS_Menu_Sub[]>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_Menu_Detail_Search(response: HttpResponseBase): Observable<SYS_Menu_Sub[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SYS_Menu_Sub.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SYS_Menu_Sub[]>(<any>null);
    }

    /**
     * @param cODE (optional) 
     * @param userID (optional) 
     * @param type (optional) 
     * @return Success
     */
    sYS_Menu_Search_byID(cODE: string | null | undefined, userID: number | undefined, type: string | null | undefined): Observable<SYS_Menu> {
        let url_ = this.baseUrl + "/api/Menu/SYS_Menu_Search_byID?";
        if (cODE !== undefined && cODE !== null)
            url_ += "CODE=" + encodeURIComponent("" + cODE) + "&";
        if (userID === null)
            throw new Error("The parameter 'userID' cannot be null.");
        else if (userID !== undefined)
            url_ += "userID=" + encodeURIComponent("" + userID) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_Menu_Search_byID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_Menu_Search_byID(<any>response_);
                } catch (e) {
                    return <Observable<SYS_Menu>><any>_observableThrow(e);
                }
            } else
                return <Observable<SYS_Menu>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_Menu_Search_byID(response: HttpResponseBase): Observable<SYS_Menu> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SYS_Menu.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SYS_Menu>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    sYS_Menu_Delete(id: number | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Menu/SYS_Menu_Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_Menu_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_Menu_Delete(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_Menu_Delete(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sYS_Menu_Inserst(body: SYS_Menu | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Menu/SYS_Menu_Inserst";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_Menu_Inserst(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_Menu_Inserst(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_Menu_Inserst(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sYS_Menu_Update(body: SYS_Menu | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Menu/SYS_Menu_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_Menu_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_Menu_Update(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_Menu_Update(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @return Success
     */
    sYS_Account_Group_Search(): Observable<SYS_Account_Group[]> {
        let url_ = this.baseUrl + "/api/Menu/SYS_Account_Group_Search";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_Account_Group_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_Account_Group_Search(<any>response_);
                } catch (e) {
                    return <Observable<SYS_Account_Group[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SYS_Account_Group[]>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_Account_Group_Search(response: HttpResponseBase): Observable<SYS_Account_Group[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SYS_Account_Group.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SYS_Account_Group[]>(<any>null);
    }
}

@Injectable()
export class ReferenceService extends ApiBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppSession) configuration: AppSession, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    sYS_Version_UI_Search(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Reference/SYS_Version_UI_Search";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSYS_Version_UI_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_Version_UI_Search(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: string; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: string; }>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_Version_UI_Search(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(<any>null);
    }

    /**
     * @param stored (optional) 
     * @param param (optional) 
     * @return Success
     */
    reference_Search_V2(stored: string | null | undefined, param: string | null | undefined): Observable<REFERENCE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Reference/Reference_Search_V2?";
        if (stored !== undefined && stored !== null)
            url_ += "stored=" + encodeURIComponent("" + stored) + "&";
        if (param !== undefined && param !== null)
            url_ += "param=" + encodeURIComponent("" + param) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processReference_Search_V2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReference_Search_V2(<any>response_);
                } catch (e) {
                    return <Observable<REFERENCE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<REFERENCE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processReference_Search_V2(response: HttpResponseBase): Observable<REFERENCE_ENTITY[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(REFERENCE_ENTITY.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<REFERENCE_ENTITY[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reference_Search(body: REFERENCE_ENTITY | undefined): Observable<REFERENCE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Reference/Reference_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processReference_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReference_Search(<any>response_);
                } catch (e) {
                    return <Observable<REFERENCE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<REFERENCE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processReference_Search(response: HttpResponseBase): Observable<REFERENCE_ENTITY[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(REFERENCE_ENTITY.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<REFERENCE_ENTITY[]>(<any>null);
    }
}

@Injectable()
export class SignalRService extends ApiBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppSession) configuration: AppSession, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    realtime_Messenger(body: Messenger | undefined): Observable<Messenger[]> {
        let url_ = this.baseUrl + "/api/SignalR/Realtime_Messenger";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRealtime_Messenger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRealtime_Messenger(<any>response_);
                } catch (e) {
                    return <Observable<Messenger[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Messenger[]>><any>_observableThrow(response_);
        }));
    }

    protected processRealtime_Messenger(response: HttpResponseBase): Observable<Messenger[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Messenger.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Messenger[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get_Messenger(body: ChatModel | undefined): Observable<ChatModel[]> {
        let url_ = this.baseUrl + "/api/SignalR/Get_Messenger";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet_Messenger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet_Messenger(<any>response_);
                } catch (e) {
                    return <Observable<ChatModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet_Messenger(response: HttpResponseBase): Observable<ChatModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChatModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    chat_GetHistoryMessenger(body: ChatModel | undefined): Observable<ChatModel[]> {
        let url_ = this.baseUrl + "/api/SignalR/Chat_GetHistoryMessenger";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processChat_GetHistoryMessenger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChat_GetHistoryMessenger(<any>response_);
                } catch (e) {
                    return <Observable<ChatModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processChat_GetHistoryMessenger(response: HttpResponseBase): Observable<ChatModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChatModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    chat_Friend_Search(body: string | null | undefined): Observable<ChatModel[]> {
        let url_ = this.baseUrl + "/api/SignalR/Chat_Friend_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processChat_Friend_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChat_Friend_Search(<any>response_);
                } catch (e) {
                    return <Observable<ChatModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processChat_Friend_Search(response: HttpResponseBase): Observable<ChatModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChatModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    chat_GetHistoryMessenger_By_Chat_ID(body: Chat_ContentModel | undefined): Observable<Chat_ContentModel[]> {
        let url_ = this.baseUrl + "/api/SignalR/Chat_GetHistoryMessenger_By_Chat_ID";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processChat_GetHistoryMessenger_By_Chat_ID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChat_GetHistoryMessenger_By_Chat_ID(<any>response_);
                } catch (e) {
                    return <Observable<Chat_ContentModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Chat_ContentModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processChat_GetHistoryMessenger_By_Chat_ID(response: HttpResponseBase): Observable<Chat_ContentModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Chat_ContentModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Chat_ContentModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    chat_Inserst(body: ChatModel | undefined): Observable<ChatModel> {
        let url_ = this.baseUrl + "/api/SignalR/Chat_Inserst";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processChat_Inserst(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChat_Inserst(<any>response_);
                } catch (e) {
                    return <Observable<ChatModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatModel>><any>_observableThrow(response_);
        }));
    }

    protected processChat_Inserst(response: HttpResponseBase): Observable<ChatModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatModel>(<any>null);
    }

    /**
     * @param chat_id (optional) 
     * @return Success
     */
    chat_Get_New_Messenger_By_Chat_ID(chat_id: number | undefined): Observable<Chat_ContentModel[]> {
        let url_ = this.baseUrl + "/api/SignalR/Chat_Get_New_Messenger_By_Chat_ID?";
        if (chat_id === null)
            throw new Error("The parameter 'chat_id' cannot be null.");
        else if (chat_id !== undefined)
            url_ += "chat_id=" + encodeURIComponent("" + chat_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processChat_Get_New_Messenger_By_Chat_ID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChat_Get_New_Messenger_By_Chat_ID(<any>response_);
                } catch (e) {
                    return <Observable<Chat_ContentModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Chat_ContentModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processChat_Get_New_Messenger_By_Chat_ID(response: HttpResponseBase): Observable<Chat_ContentModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Chat_ContentModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Chat_ContentModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hRM_Notification_Search(body: NotificationModel | undefined): Observable<NotificationModel[]> {
        let url_ = this.baseUrl + "/api/SignalR/HRM_Notification_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_Notification_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_Notification_Search(<any>response_);
                } catch (e) {
                    return <Observable<NotificationModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_Notification_Search(response: HttpResponseBase): Observable<NotificationModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(NotificationModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationModel[]>(<any>null);
    }
}

@Injectable()
export class TestThemeService extends ApiBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppSession) configuration: AppSession, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    testTheme_Search_byID(code: string | null | undefined): Observable<Tb_TestTheme_ENTITY> {
        let url_ = this.baseUrl + "/api/TestTheme/TestTheme_Search_byID?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTestTheme_Search_byID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestTheme_Search_byID(<any>response_);
                } catch (e) {
                    return <Observable<Tb_TestTheme_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<Tb_TestTheme_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processTestTheme_Search_byID(response: HttpResponseBase): Observable<Tb_TestTheme_ENTITY> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Tb_TestTheme_ENTITY.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tb_TestTheme_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    testTheme_Update(body: Tb_TestTheme_ENTITY | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/TestTheme/TestTheme_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTestTheme_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestTheme_Update(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processTestTheme_Update(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    testTheme_Insert(body: Tb_TestTheme_ENTITY | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/TestTheme/TestTheme_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTestTheme_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestTheme_Insert(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processTestTheme_Insert(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    testTheme_Search(body: Tb_TestTheme_ENTITY | undefined): Observable<Tb_TestTheme_ENTITY[]> {
        let url_ = this.baseUrl + "/api/TestTheme/TestTheme_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTestTheme_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestTheme_Search(<any>response_);
                } catch (e) {
                    return <Observable<Tb_TestTheme_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Tb_TestTheme_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processTestTheme_Search(response: HttpResponseBase): Observable<Tb_TestTheme_ENTITY[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Tb_TestTheme_ENTITY.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tb_TestTheme_ENTITY[]>(<any>null);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    testTheme_Del(code: string | null | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/TestTheme/TestTheme_Del?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTestTheme_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestTheme_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processTestTheme_Del(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }
}

@Injectable()
export class TimeSheetService extends ApiBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppSession) configuration: AppSession, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param iD (optional) 
     * @param constHour (optional) 
     * @param hourStartMonth (optional) 
     * @param employee_ID (optional) 
     * @param title (optional) 
     * @param start (optional) 
     * @param allday (optional) 
     * @param type_ID (optional) 
     * @param className (optional) 
     * @param hRM_TimeSheet_Details (optional) 
     * @param code (optional) 
     * @param aPPROVE (optional) 
     * @param dATE_ADD (optional) 
     * @param dATE_EDIT (optional) 
     * @param aCCOUNT_ID (optional) 
     * @param nOTES (optional) 
     * @param dECENTRALIZATION (optional) 
     * @return Success
     */
    hRM_TimeSheet_Insert(iD: number | null | undefined, constHour: number | null | undefined, hourStartMonth: number | null | undefined, employee_ID: number | null | undefined, title: string | null | undefined, start: number | null | undefined, allday: number | null | undefined, type_ID: number | null | undefined, className: string | null | undefined, hRM_TimeSheet_Details: HRM_TimeSheet_Detail_ENTITY[] | null | undefined, code: string | null | undefined, aPPROVE: boolean | null | undefined, dATE_ADD: moment.Moment | null | undefined, dATE_EDIT: moment.Moment | null | undefined, aCCOUNT_ID: number | null | undefined, nOTES: string | null | undefined, dECENTRALIZATION: string | null | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/TimeSheet/HRM_TimeSheet_Insert?";
        if (iD !== undefined && iD !== null)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (constHour !== undefined && constHour !== null)
            url_ += "ConstHour=" + encodeURIComponent("" + constHour) + "&";
        if (hourStartMonth !== undefined && hourStartMonth !== null)
            url_ += "HourStartMonth=" + encodeURIComponent("" + hourStartMonth) + "&";
        if (employee_ID !== undefined && employee_ID !== null)
            url_ += "Employee_ID=" + encodeURIComponent("" + employee_ID) + "&";
        if (title !== undefined && title !== null)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (start !== undefined && start !== null)
            url_ += "Start=" + encodeURIComponent("" + start) + "&";
        if (allday !== undefined && allday !== null)
            url_ += "Allday=" + encodeURIComponent("" + allday) + "&";
        if (type_ID !== undefined && type_ID !== null)
            url_ += "Type_ID=" + encodeURIComponent("" + type_ID) + "&";
        if (className !== undefined && className !== null)
            url_ += "ClassName=" + encodeURIComponent("" + className) + "&";
        if (hRM_TimeSheet_Details !== undefined && hRM_TimeSheet_Details !== null)
            hRM_TimeSheet_Details && hRM_TimeSheet_Details.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "hRM_TimeSheet_Details[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (aPPROVE !== undefined && aPPROVE !== null)
            url_ += "APPROVE=" + encodeURIComponent("" + aPPROVE) + "&";
        if (dATE_ADD !== undefined && dATE_ADD !== null)
            url_ += "DATE_ADD=" + encodeURIComponent(dATE_ADD ? "" + dATE_ADD.toJSON() : "") + "&";
        if (dATE_EDIT !== undefined && dATE_EDIT !== null)
            url_ += "DATE_EDIT=" + encodeURIComponent(dATE_EDIT ? "" + dATE_EDIT.toJSON() : "") + "&";
        if (aCCOUNT_ID !== undefined && aCCOUNT_ID !== null)
            url_ += "ACCOUNT_ID=" + encodeURIComponent("" + aCCOUNT_ID) + "&";
        if (nOTES !== undefined && nOTES !== null)
            url_ += "NOTES=" + encodeURIComponent("" + nOTES) + "&";
        if (dECENTRALIZATION !== undefined && dECENTRALIZATION !== null)
            url_ += "DECENTRALIZATION=" + encodeURIComponent("" + dECENTRALIZATION) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_TimeSheet_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_TimeSheet_Insert(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_TimeSheet_Insert(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param iD (optional) 
     * @param constHour (optional) 
     * @param hourStartMonth (optional) 
     * @param employee_ID (optional) 
     * @param title (optional) 
     * @param start (optional) 
     * @param allday (optional) 
     * @param type_ID (optional) 
     * @param className (optional) 
     * @param hRM_TimeSheet_Details (optional) 
     * @param code (optional) 
     * @param aPPROVE (optional) 
     * @param dATE_ADD (optional) 
     * @param dATE_EDIT (optional) 
     * @param aCCOUNT_ID (optional) 
     * @param nOTES (optional) 
     * @param dECENTRALIZATION (optional) 
     * @return Success
     */
    hRM_TimeSheet_Search(iD: number | null | undefined, constHour: number | null | undefined, hourStartMonth: number | null | undefined, employee_ID: number | null | undefined, title: string | null | undefined, start: number | null | undefined, allday: number | null | undefined, type_ID: number | null | undefined, className: string | null | undefined, hRM_TimeSheet_Details: HRM_TimeSheet_Detail_ENTITY[] | null | undefined, code: string | null | undefined, aPPROVE: boolean | null | undefined, dATE_ADD: moment.Moment | null | undefined, dATE_EDIT: moment.Moment | null | undefined, aCCOUNT_ID: number | null | undefined, nOTES: string | null | undefined, dECENTRALIZATION: string | null | undefined): Observable<HRM_TimeSheet_ENTITY[]> {
        let url_ = this.baseUrl + "/api/TimeSheet/HRM_TimeSheet_Search?";
        if (iD !== undefined && iD !== null)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (constHour !== undefined && constHour !== null)
            url_ += "ConstHour=" + encodeURIComponent("" + constHour) + "&";
        if (hourStartMonth !== undefined && hourStartMonth !== null)
            url_ += "HourStartMonth=" + encodeURIComponent("" + hourStartMonth) + "&";
        if (employee_ID !== undefined && employee_ID !== null)
            url_ += "Employee_ID=" + encodeURIComponent("" + employee_ID) + "&";
        if (title !== undefined && title !== null)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (start !== undefined && start !== null)
            url_ += "Start=" + encodeURIComponent("" + start) + "&";
        if (allday !== undefined && allday !== null)
            url_ += "Allday=" + encodeURIComponent("" + allday) + "&";
        if (type_ID !== undefined && type_ID !== null)
            url_ += "Type_ID=" + encodeURIComponent("" + type_ID) + "&";
        if (className !== undefined && className !== null)
            url_ += "ClassName=" + encodeURIComponent("" + className) + "&";
        if (hRM_TimeSheet_Details !== undefined && hRM_TimeSheet_Details !== null)
            hRM_TimeSheet_Details && hRM_TimeSheet_Details.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "hRM_TimeSheet_Details[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (aPPROVE !== undefined && aPPROVE !== null)
            url_ += "APPROVE=" + encodeURIComponent("" + aPPROVE) + "&";
        if (dATE_ADD !== undefined && dATE_ADD !== null)
            url_ += "DATE_ADD=" + encodeURIComponent(dATE_ADD ? "" + dATE_ADD.toJSON() : "") + "&";
        if (dATE_EDIT !== undefined && dATE_EDIT !== null)
            url_ += "DATE_EDIT=" + encodeURIComponent(dATE_EDIT ? "" + dATE_EDIT.toJSON() : "") + "&";
        if (aCCOUNT_ID !== undefined && aCCOUNT_ID !== null)
            url_ += "ACCOUNT_ID=" + encodeURIComponent("" + aCCOUNT_ID) + "&";
        if (nOTES !== undefined && nOTES !== null)
            url_ += "NOTES=" + encodeURIComponent("" + nOTES) + "&";
        if (dECENTRALIZATION !== undefined && dECENTRALIZATION !== null)
            url_ += "DECENTRALIZATION=" + encodeURIComponent("" + dECENTRALIZATION) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_TimeSheet_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_TimeSheet_Search(<any>response_);
                } catch (e) {
                    return <Observable<HRM_TimeSheet_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HRM_TimeSheet_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_TimeSheet_Search(response: HttpResponseBase): Observable<HRM_TimeSheet_ENTITY[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HRM_TimeSheet_ENTITY.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HRM_TimeSheet_ENTITY[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hRM_TimeSheet_Search_Detail(id: number | undefined): Observable<HRM_TimeSheet_Detail_ENTITY[]> {
        let url_ = this.baseUrl + "/api/TimeSheet/HRM_TimeSheet_Search_Detail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_TimeSheet_Search_Detail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_TimeSheet_Search_Detail(<any>response_);
                } catch (e) {
                    return <Observable<HRM_TimeSheet_Detail_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HRM_TimeSheet_Detail_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_TimeSheet_Search_Detail(response: HttpResponseBase): Observable<HRM_TimeSheet_Detail_ENTITY[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HRM_TimeSheet_Detail_ENTITY.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HRM_TimeSheet_Detail_ENTITY[]>(<any>null);
    }

    /**
     * @param iD (optional) 
     * @param constHour (optional) 
     * @param hourStartMonth (optional) 
     * @param employee_ID (optional) 
     * @param title (optional) 
     * @param start (optional) 
     * @param allday (optional) 
     * @param type_ID (optional) 
     * @param className (optional) 
     * @param hRM_TimeSheet_Details (optional) 
     * @param code (optional) 
     * @param aPPROVE (optional) 
     * @param dATE_ADD (optional) 
     * @param dATE_EDIT (optional) 
     * @param aCCOUNT_ID (optional) 
     * @param nOTES (optional) 
     * @param dECENTRALIZATION (optional) 
     * @return Success
     */
    hRM_TimeSheet_Update(iD: number | null | undefined, constHour: number | null | undefined, hourStartMonth: number | null | undefined, employee_ID: number | null | undefined, title: string | null | undefined, start: number | null | undefined, allday: number | null | undefined, type_ID: number | null | undefined, className: string | null | undefined, hRM_TimeSheet_Details: HRM_TimeSheet_Detail_ENTITY[] | null | undefined, code: string | null | undefined, aPPROVE: boolean | null | undefined, dATE_ADD: moment.Moment | null | undefined, dATE_EDIT: moment.Moment | null | undefined, aCCOUNT_ID: number | null | undefined, nOTES: string | null | undefined, dECENTRALIZATION: string | null | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/TimeSheet/HRM_TimeSheet_Update?";
        if (iD !== undefined && iD !== null)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (constHour !== undefined && constHour !== null)
            url_ += "ConstHour=" + encodeURIComponent("" + constHour) + "&";
        if (hourStartMonth !== undefined && hourStartMonth !== null)
            url_ += "HourStartMonth=" + encodeURIComponent("" + hourStartMonth) + "&";
        if (employee_ID !== undefined && employee_ID !== null)
            url_ += "Employee_ID=" + encodeURIComponent("" + employee_ID) + "&";
        if (title !== undefined && title !== null)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (start !== undefined && start !== null)
            url_ += "Start=" + encodeURIComponent("" + start) + "&";
        if (allday !== undefined && allday !== null)
            url_ += "Allday=" + encodeURIComponent("" + allday) + "&";
        if (type_ID !== undefined && type_ID !== null)
            url_ += "Type_ID=" + encodeURIComponent("" + type_ID) + "&";
        if (className !== undefined && className !== null)
            url_ += "ClassName=" + encodeURIComponent("" + className) + "&";
        if (hRM_TimeSheet_Details !== undefined && hRM_TimeSheet_Details !== null)
            hRM_TimeSheet_Details && hRM_TimeSheet_Details.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "hRM_TimeSheet_Details[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (aPPROVE !== undefined && aPPROVE !== null)
            url_ += "APPROVE=" + encodeURIComponent("" + aPPROVE) + "&";
        if (dATE_ADD !== undefined && dATE_ADD !== null)
            url_ += "DATE_ADD=" + encodeURIComponent(dATE_ADD ? "" + dATE_ADD.toJSON() : "") + "&";
        if (dATE_EDIT !== undefined && dATE_EDIT !== null)
            url_ += "DATE_EDIT=" + encodeURIComponent(dATE_EDIT ? "" + dATE_EDIT.toJSON() : "") + "&";
        if (aCCOUNT_ID !== undefined && aCCOUNT_ID !== null)
            url_ += "ACCOUNT_ID=" + encodeURIComponent("" + aCCOUNT_ID) + "&";
        if (nOTES !== undefined && nOTES !== null)
            url_ += "NOTES=" + encodeURIComponent("" + nOTES) + "&";
        if (dECENTRALIZATION !== undefined && dECENTRALIZATION !== null)
            url_ += "DECENTRALIZATION=" + encodeURIComponent("" + dECENTRALIZATION) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_TimeSheet_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_TimeSheet_Update(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_TimeSheet_Update(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }
}

@Injectable()
export class ToolService extends ApiBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppSession) configuration: AppSession, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deCryptString(body: CRYPTModel | undefined): Observable<CRYPTModel> {
        let url_ = this.baseUrl + "/api/Tool/DeCryptString";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeCryptString(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeCryptString(<any>response_);
                } catch (e) {
                    return <Observable<CRYPTModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<CRYPTModel>><any>_observableThrow(response_);
        }));
    }

    protected processDeCryptString(response: HttpResponseBase): Observable<CRYPTModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CRYPTModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CRYPTModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    enCryptString(body: CRYPTModel | undefined): Observable<CRYPTModel> {
        let url_ = this.baseUrl + "/api/Tool/EnCryptString";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processEnCryptString(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnCryptString(<any>response_);
                } catch (e) {
                    return <Observable<CRYPTModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<CRYPTModel>><any>_observableThrow(response_);
        }));
    }

    protected processEnCryptString(response: HttpResponseBase): Observable<CRYPTModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CRYPTModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CRYPTModel>(<any>null);
    }
}

@Injectable()
export class WorkspaceService extends ApiBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppSession) configuration: AppSession, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    hRM_Workspace_Comment_ByCode_Calendar(code: string | null | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Workspace/HRM_Workspace_Comment_ByCode_Calendar?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_Workspace_Comment_ByCode_Calendar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_Workspace_Comment_ByCode_Calendar(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_Workspace_Comment_ByCode_Calendar(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param listID (optional) 
     * @return Success
     */
    hRM_Workspace_Delete(listID: string | null | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Workspace/HRM_Workspace_Delete?";
        if (listID !== undefined && listID !== null)
            url_ += "listID=" + encodeURIComponent("" + listID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_Workspace_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_Workspace_Delete(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_Workspace_Delete(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hRM_Workspace_Insert(body: HRM_Workspace_Master_ENTITY | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Workspace/HRM_Workspace_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_Workspace_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_Workspace_Insert(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_Workspace_Insert(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hRM_Workspace_Search(body: HRM_Workspace_ENTITY | undefined): Observable<HRM_Workspace_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Workspace/HRM_Workspace_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_Workspace_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_Workspace_Search(<any>response_);
                } catch (e) {
                    return <Observable<HRM_Workspace_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HRM_Workspace_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_Workspace_Search(response: HttpResponseBase): Observable<HRM_Workspace_ENTITY[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HRM_Workspace_ENTITY.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HRM_Workspace_ENTITY[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hRM_Workspace_Search_ByID(id: number | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Workspace/HRM_Workspace_Search_ByID?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_Workspace_Search_ByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_Workspace_Search_ByID(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_Workspace_Search_ByID(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hRM_Workspace_Update(body: HRM_Workspace_Master_ENTITY | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Workspace/HRM_Workspace_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_Workspace_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_Workspace_Update(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_Workspace_Update(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hRM_Workspace_Comment_Update(body: HRM_Workspace_Comment_ENTITY | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Workspace/HRM_Workspace_Comment_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_Workspace_Comment_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_Workspace_Comment_Update(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_Workspace_Comment_Update(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hRM_Workspace_Comment_Insert(body: HRM_Workspace_Comment_ENTITY | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Workspace/HRM_Workspace_Comment_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_Workspace_Comment_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_Workspace_Comment_Insert(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_Workspace_Comment_Insert(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hRM_Workspace_Master_Search(body: HRM_Workspace_Master_ENTITY | undefined): Observable<HRM_Workspace_Master_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Workspace/HRM_Workspace_Master_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_Workspace_Master_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_Workspace_Master_Search(<any>response_);
                } catch (e) {
                    return <Observable<HRM_Workspace_Master_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HRM_Workspace_Master_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_Workspace_Master_Search(response: HttpResponseBase): Observable<HRM_Workspace_Master_ENTITY[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HRM_Workspace_Master_ENTITY.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HRM_Workspace_Master_ENTITY[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hRM_Workspace_Update_Timesheet(body: HRM_Workspace_ENTITY | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Workspace/HRM_Workspace_Update_Timesheet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_Workspace_Update_Timesheet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_Workspace_Update_Timesheet(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_Workspace_Update_Timesheet(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }

    /**
     * @param code_master (optional) 
     * @param idCalendar (optional) 
     * @param top (optional) 
     * @return Success
     */
    hRM_Workspace_Timesheet_Search_By_IDCalendar(code_master: string | null | undefined, idCalendar: string | null | undefined, top: number | undefined): Observable<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/api/Workspace/HRM_Workspace_Timesheet_Search_By_IDCalendar?";
        if (code_master !== undefined && code_master !== null)
            url_ += "code_master=" + encodeURIComponent("" + code_master) + "&";
        if (idCalendar !== undefined && idCalendar !== null)
            url_ += "idCalendar=" + encodeURIComponent("" + idCalendar) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "top=" + encodeURIComponent("" + top) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processHRM_Workspace_Timesheet_Search_By_IDCalendar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHRM_Workspace_Timesheet_Search_By_IDCalendar(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: any; }>><any>_observableThrow(response_);
        }));
    }

    protected processHRM_Workspace_Timesheet_Search_By_IDCalendar(response: HttpResponseBase): Observable<{ [key: string]: any; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: any; }>(<any>null);
    }
}

export class SYS_Account_Group implements ISYS_Account_Group {
    id?: number;
    accounT_ID?: number | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    log?: string | undefined;
    notes?: string | undefined;
    name?: string | undefined;
    listaccount?: string | undefined;
    code?: string | undefined;
    syS_Account_Infomation?: SYS_Account_Group[] | undefined;
    decentralization?: string | undefined;
    approve?: boolean | undefined;

    constructor(data?: ISYS_Account_Group) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accounT_ID = _data["accounT_ID"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.log = _data["log"];
            this.notes = _data["notes"];
            this.name = _data["name"];
            this.listaccount = _data["listaccount"];
            this.code = _data["code"];
            if (Array.isArray(_data["syS_Account_Infomation"])) {
                this.syS_Account_Infomation = [] as any;
                for (let item of _data["syS_Account_Infomation"])
                    this.syS_Account_Infomation.push(SYS_Account_Group.fromJS(item));
            }
            this.decentralization = _data["decentralization"];
            this.approve = _data["approve"];
        }
    }

    static fromJS(data: any): SYS_Account_Group {
        data = typeof data === 'object' ? data : {};
        let result = new SYS_Account_Group();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accounT_ID"] = this.accounT_ID;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["log"] = this.log;
        data["notes"] = this.notes;
        data["name"] = this.name;
        data["listaccount"] = this.listaccount;
        data["code"] = this.code;
        if (Array.isArray(this.syS_Account_Infomation)) {
            data["syS_Account_Infomation"] = [];
            for (let item of this.syS_Account_Infomation)
                data["syS_Account_Infomation"].push(item.toJSON());
        }
        data["decentralization"] = this.decentralization;
        data["approve"] = this.approve;
        return data; 
    }

    clone(): SYS_Account_Group {
        const json = this.toJSON();
        let result = new SYS_Account_Group();
        result.init(json);
        return result;
    }
}

export interface ISYS_Account_Group {
    id?: number;
    accounT_ID?: number | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    log?: string | undefined;
    notes?: string | undefined;
    name?: string | undefined;
    listaccount?: string | undefined;
    code?: string | undefined;
    syS_Account_Infomation?: SYS_Account_Group[] | undefined;
    decentralization?: string | undefined;
    approve?: boolean | undefined;
}

export class SYS_Account_Infomation implements ISYS_Account_Infomation {
    id?: number;
    accounT_ID?: number | undefined;
    accounT_GROUP?: number | undefined;
    accounT_GROUP_NAME?: string | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    log?: string | undefined;
    notes?: string | undefined;
    useR_NAME?: string | undefined;
    password?: string | undefined;
    code?: string | undefined;
    code_employee?: string | undefined;
    decentralization?: string | undefined;
    active?: boolean | undefined;
    avarta?: string | undefined;
    lasT_NAME?: string | undefined;
    firsT_NAME?: string | undefined;
    approve?: boolean | undefined;
    mobilE_NUMBER?: string | undefined;
    address?: string | undefined;
    addresS_CURRENT?: string | undefined;
    iD_CARD?: string | undefined;
    birthday?: moment.Moment | undefined;
    position?: number | undefined;
    email?: string | undefined;
    education?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    experience?: string | undefined;
    additionaL_DETAILS?: string | undefined;

    constructor(data?: ISYS_Account_Infomation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accounT_ID = _data["accounT_ID"];
            this.accounT_GROUP = _data["accounT_GROUP"];
            this.accounT_GROUP_NAME = _data["accounT_GROUP_NAME"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.log = _data["log"];
            this.notes = _data["notes"];
            this.useR_NAME = _data["useR_NAME"];
            this.password = _data["password"];
            this.code = _data["code"];
            this.code_employee = _data["code_employee"];
            this.decentralization = _data["decentralization"];
            this.active = _data["active"];
            this.avarta = _data["avarta"];
            this.lasT_NAME = _data["lasT_NAME"];
            this.firsT_NAME = _data["firsT_NAME"];
            this.approve = _data["approve"];
            this.mobilE_NUMBER = _data["mobilE_NUMBER"];
            this.address = _data["address"];
            this.addresS_CURRENT = _data["addresS_CURRENT"];
            this.iD_CARD = _data["iD_CARD"];
            this.birthday = _data["birthday"] ? moment.parseZone(_data["birthday"].toString()) : <any>undefined;
            this.position = _data["position"];
            this.email = _data["email"];
            this.education = _data["education"];
            this.country = _data["country"];
            this.city = _data["city"];
            this.experience = _data["experience"];
            this.additionaL_DETAILS = _data["additionaL_DETAILS"];
        }
    }

    static fromJS(data: any): SYS_Account_Infomation {
        data = typeof data === 'object' ? data : {};
        let result = new SYS_Account_Infomation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accounT_ID"] = this.accounT_ID;
        data["accounT_GROUP"] = this.accounT_GROUP;
        data["accounT_GROUP_NAME"] = this.accounT_GROUP_NAME;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["log"] = this.log;
        data["notes"] = this.notes;
        data["useR_NAME"] = this.useR_NAME;
        data["password"] = this.password;
        data["code"] = this.code;
        data["code_employee"] = this.code_employee;
        data["decentralization"] = this.decentralization;
        data["active"] = this.active;
        data["avarta"] = this.avarta;
        data["lasT_NAME"] = this.lasT_NAME;
        data["firsT_NAME"] = this.firsT_NAME;
        data["approve"] = this.approve;
        data["mobilE_NUMBER"] = this.mobilE_NUMBER;
        data["address"] = this.address;
        data["addresS_CURRENT"] = this.addresS_CURRENT;
        data["iD_CARD"] = this.iD_CARD;
        data["birthday"] = this.birthday ? this.birthday.toISOString(true) : <any>undefined;
        data["position"] = this.position;
        data["email"] = this.email;
        data["education"] = this.education;
        data["country"] = this.country;
        data["city"] = this.city;
        data["experience"] = this.experience;
        data["additionaL_DETAILS"] = this.additionaL_DETAILS;
        return data; 
    }

    clone(): SYS_Account_Infomation {
        const json = this.toJSON();
        let result = new SYS_Account_Infomation();
        result.init(json);
        return result;
    }
}

export interface ISYS_Account_Infomation {
    id?: number;
    accounT_ID?: number | undefined;
    accounT_GROUP?: number | undefined;
    accounT_GROUP_NAME?: string | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    log?: string | undefined;
    notes?: string | undefined;
    useR_NAME?: string | undefined;
    password?: string | undefined;
    code?: string | undefined;
    code_employee?: string | undefined;
    decentralization?: string | undefined;
    active?: boolean | undefined;
    avarta?: string | undefined;
    lasT_NAME?: string | undefined;
    firsT_NAME?: string | undefined;
    approve?: boolean | undefined;
    mobilE_NUMBER?: string | undefined;
    address?: string | undefined;
    addresS_CURRENT?: string | undefined;
    iD_CARD?: string | undefined;
    birthday?: moment.Moment | undefined;
    position?: number | undefined;
    email?: string | undefined;
    education?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    experience?: string | undefined;
    additionaL_DETAILS?: string | undefined;
}

export class RequestManagement_ENTITY implements IRequestManagement_ENTITY {
    username?: string | undefined;
    token?: string | undefined;
    lastRequest?: moment.Moment | undefined;
    firstRequest?: moment.Moment | undefined;
    countLogin?: string | undefined;
    expiryDate?: moment.Moment | undefined;
    timeOut?: number | undefined;
    userAgent?: string | undefined;
    sec_ch_ua?: string | undefined;
    sec_ch_ua_platform?: string | undefined;
    isonline?: boolean | undefined;
    lastonlile?: string | undefined;
    hour_LastLogin?: number;

    constructor(data?: IRequestManagement_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.token = _data["token"];
            this.lastRequest = _data["lastRequest"] ? moment.parseZone(_data["lastRequest"].toString()) : <any>undefined;
            this.firstRequest = _data["firstRequest"] ? moment.parseZone(_data["firstRequest"].toString()) : <any>undefined;
            this.countLogin = _data["countLogin"];
            this.expiryDate = _data["expiryDate"] ? moment.parseZone(_data["expiryDate"].toString()) : <any>undefined;
            this.timeOut = _data["timeOut"];
            this.userAgent = _data["userAgent"];
            this.sec_ch_ua = _data["sec_ch_ua"];
            this.sec_ch_ua_platform = _data["sec_ch_ua_platform"];
            this.isonline = _data["isonline"];
            this.lastonlile = _data["lastonlile"];
            this.hour_LastLogin = _data["hour_LastLogin"];
        }
    }

    static fromJS(data: any): RequestManagement_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new RequestManagement_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["token"] = this.token;
        data["lastRequest"] = this.lastRequest ? this.lastRequest.toISOString(true) : <any>undefined;
        data["firstRequest"] = this.firstRequest ? this.firstRequest.toISOString(true) : <any>undefined;
        data["countLogin"] = this.countLogin;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString(true) : <any>undefined;
        data["timeOut"] = this.timeOut;
        data["userAgent"] = this.userAgent;
        data["sec_ch_ua"] = this.sec_ch_ua;
        data["sec_ch_ua_platform"] = this.sec_ch_ua_platform;
        data["isonline"] = this.isonline;
        data["lastonlile"] = this.lastonlile;
        data["hour_LastLogin"] = this.hour_LastLogin;
        return data; 
    }

    clone(): RequestManagement_ENTITY {
        const json = this.toJSON();
        let result = new RequestManagement_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IRequestManagement_ENTITY {
    username?: string | undefined;
    token?: string | undefined;
    lastRequest?: moment.Moment | undefined;
    firstRequest?: moment.Moment | undefined;
    countLogin?: string | undefined;
    expiryDate?: moment.Moment | undefined;
    timeOut?: number | undefined;
    userAgent?: string | undefined;
    sec_ch_ua?: string | undefined;
    sec_ch_ua_platform?: string | undefined;
    isonline?: boolean | undefined;
    lastonlile?: string | undefined;
    hour_LastLogin?: number;
}

export class Mail_ENTITY implements IMail_ENTITY {
    email?: string | undefined;

    constructor(data?: IMail_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): Mail_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new Mail_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data; 
    }

    clone(): Mail_ENTITY {
        const json = this.toJSON();
        let result = new Mail_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IMail_ENTITY {
    email?: string | undefined;
}

export class SYS_ActionsOnTable_ENTITY implements ISYS_ActionsOnTable_ENTITY {
    id?: number;
    colAccountID?: number | undefined;
    active?: boolean | undefined;
    role?: boolean | undefined;
    name?: string | undefined;
    indexRow?: number | undefined;
    link?: string | undefined;
    tbName?: string | undefined;
    storedName?: string | undefined;
    onInit?: string | undefined;
    classForm?: string | undefined;
    onForm?: string | undefined;
    icon?: string | undefined;
    position?: number | undefined;
    userID?: number | undefined;
    keyService?: string | undefined;
    permission?: string | undefined;
    namE_VN?: string | undefined;
    namE_EN?: string | undefined;
    param?: string | undefined;
    rollBack?: string | undefined;
    rollNext?: string | undefined;
    lisT_ACCTIONS?: string | undefined;
    code?: string | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;

    constructor(data?: ISYS_ActionsOnTable_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.colAccountID = _data["colAccountID"];
            this.active = _data["active"];
            this.role = _data["role"];
            this.name = _data["name"];
            this.indexRow = _data["indexRow"];
            this.link = _data["link"];
            this.tbName = _data["tbName"];
            this.storedName = _data["storedName"];
            this.onInit = _data["onInit"];
            this.classForm = _data["classForm"];
            this.onForm = _data["onForm"];
            this.icon = _data["icon"];
            this.position = _data["position"];
            this.userID = _data["userID"];
            this.keyService = _data["keyService"];
            this.permission = _data["permission"];
            this.namE_VN = _data["namE_VN"];
            this.namE_EN = _data["namE_EN"];
            this.param = _data["param"];
            this.rollBack = _data["rollBack"];
            this.rollNext = _data["rollNext"];
            this.lisT_ACCTIONS = _data["lisT_ACCTIONS"];
            this.code = _data["code"];
            this.approve = _data["approve"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.decentralization = _data["decentralization"];
        }
    }

    static fromJS(data: any): SYS_ActionsOnTable_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new SYS_ActionsOnTable_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["colAccountID"] = this.colAccountID;
        data["active"] = this.active;
        data["role"] = this.role;
        data["name"] = this.name;
        data["indexRow"] = this.indexRow;
        data["link"] = this.link;
        data["tbName"] = this.tbName;
        data["storedName"] = this.storedName;
        data["onInit"] = this.onInit;
        data["classForm"] = this.classForm;
        data["onForm"] = this.onForm;
        data["icon"] = this.icon;
        data["position"] = this.position;
        data["userID"] = this.userID;
        data["keyService"] = this.keyService;
        data["permission"] = this.permission;
        data["namE_VN"] = this.namE_VN;
        data["namE_EN"] = this.namE_EN;
        data["param"] = this.param;
        data["rollBack"] = this.rollBack;
        data["rollNext"] = this.rollNext;
        data["lisT_ACCTIONS"] = this.lisT_ACCTIONS;
        data["code"] = this.code;
        data["approve"] = this.approve;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["decentralization"] = this.decentralization;
        return data; 
    }

    clone(): SYS_ActionsOnTable_ENTITY {
        const json = this.toJSON();
        let result = new SYS_ActionsOnTable_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ISYS_ActionsOnTable_ENTITY {
    id?: number;
    colAccountID?: number | undefined;
    active?: boolean | undefined;
    role?: boolean | undefined;
    name?: string | undefined;
    indexRow?: number | undefined;
    link?: string | undefined;
    tbName?: string | undefined;
    storedName?: string | undefined;
    onInit?: string | undefined;
    classForm?: string | undefined;
    onForm?: string | undefined;
    icon?: string | undefined;
    position?: number | undefined;
    userID?: number | undefined;
    keyService?: string | undefined;
    permission?: string | undefined;
    namE_VN?: string | undefined;
    namE_EN?: string | undefined;
    param?: string | undefined;
    rollBack?: string | undefined;
    rollNext?: string | undefined;
    lisT_ACCTIONS?: string | undefined;
    code?: string | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;
}

export class Employee_Positions_ENTITY implements IEmployee_Positions_ENTITY {
    id?: number;
    name?: string | undefined;
    notes?: string | undefined;

    constructor(data?: IEmployee_Positions_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): Employee_Positions_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new Employee_Positions_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["notes"] = this.notes;
        return data; 
    }

    clone(): Employee_Positions_ENTITY {
        const json = this.toJSON();
        let result = new Employee_Positions_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IEmployee_Positions_ENTITY {
    id?: number;
    name?: string | undefined;
    notes?: string | undefined;
}

export class HRM_Employee_ENTITY implements IHRM_Employee_ENTITY {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    avarta?: string | undefined;
    address_Current?: string | undefined;
    iD_Card?: string | undefined;
    birthday?: moment.Moment | undefined;
    position_ID?: number | undefined;
    inBranch?: number | undefined;
    email?: string | undefined;
    education?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    experience?: string | undefined;
    experience_Description?: string | undefined;
    workingHourOnMonth?: number | undefined;
    branchName?: string | undefined;
    code?: string | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;

    constructor(data?: IHRM_Employee_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.avarta = _data["avarta"];
            this.address_Current = _data["address_Current"];
            this.iD_Card = _data["iD_Card"];
            this.birthday = _data["birthday"] ? moment.parseZone(_data["birthday"].toString()) : <any>undefined;
            this.position_ID = _data["position_ID"];
            this.inBranch = _data["inBranch"];
            this.email = _data["email"];
            this.education = _data["education"];
            this.country = _data["country"];
            this.city = _data["city"];
            this.experience = _data["experience"];
            this.experience_Description = _data["experience_Description"];
            this.workingHourOnMonth = _data["workingHourOnMonth"];
            this.branchName = _data["branchName"];
            this.code = _data["code"];
            this.approve = _data["approve"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.decentralization = _data["decentralization"];
        }
    }

    static fromJS(data: any): HRM_Employee_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HRM_Employee_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["avarta"] = this.avarta;
        data["address_Current"] = this.address_Current;
        data["iD_Card"] = this.iD_Card;
        data["birthday"] = this.birthday ? this.birthday.toISOString(true) : <any>undefined;
        data["position_ID"] = this.position_ID;
        data["inBranch"] = this.inBranch;
        data["email"] = this.email;
        data["education"] = this.education;
        data["country"] = this.country;
        data["city"] = this.city;
        data["experience"] = this.experience;
        data["experience_Description"] = this.experience_Description;
        data["workingHourOnMonth"] = this.workingHourOnMonth;
        data["branchName"] = this.branchName;
        data["code"] = this.code;
        data["approve"] = this.approve;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["decentralization"] = this.decentralization;
        return data; 
    }

    clone(): HRM_Employee_ENTITY {
        const json = this.toJSON();
        let result = new HRM_Employee_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHRM_Employee_ENTITY {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    avarta?: string | undefined;
    address_Current?: string | undefined;
    iD_Card?: string | undefined;
    birthday?: moment.Moment | undefined;
    position_ID?: number | undefined;
    inBranch?: number | undefined;
    email?: string | undefined;
    education?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    experience?: string | undefined;
    experience_Description?: string | undefined;
    workingHourOnMonth?: number | undefined;
    branchName?: string | undefined;
    code?: string | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;
}

export class InsertFile implements IInsertFile {
    id?: number;
    myFile?: string | undefined;

    constructor(data?: IInsertFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.myFile = _data["myFile"];
        }
    }

    static fromJS(data: any): InsertFile {
        data = typeof data === 'object' ? data : {};
        let result = new InsertFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["myFile"] = this.myFile;
        return data; 
    }

    clone(): InsertFile {
        const json = this.toJSON();
        let result = new InsertFile();
        result.init(json);
        return result;
    }
}

export interface IInsertFile {
    id?: number;
    myFile?: string | undefined;
}

export class File_ENTITY implements IFile_ENTITY {
    id?: number;
    path?: string | undefined;
    code?: string | undefined;
    fileName?: string | undefined;
    size?: number;
    tbName?: string | undefined;
    colName?: string | undefined;
    ref_MasterID?: number | undefined;
    index?: number;
    description?: string | undefined;
    lastModified?: string | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;

    constructor(data?: IFile_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.path = _data["path"];
            this.code = _data["code"];
            this.fileName = _data["fileName"];
            this.size = _data["size"];
            this.tbName = _data["tbName"];
            this.colName = _data["colName"];
            this.ref_MasterID = _data["ref_MasterID"];
            this.index = _data["index"];
            this.description = _data["description"];
            this.lastModified = _data["lastModified"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
        }
    }

    static fromJS(data: any): File_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new File_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["path"] = this.path;
        data["code"] = this.code;
        data["fileName"] = this.fileName;
        data["size"] = this.size;
        data["tbName"] = this.tbName;
        data["colName"] = this.colName;
        data["ref_MasterID"] = this.ref_MasterID;
        data["index"] = this.index;
        data["description"] = this.description;
        data["lastModified"] = this.lastModified;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        return data; 
    }

    clone(): File_ENTITY {
        const json = this.toJSON();
        let result = new File_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IFile_ENTITY {
    id?: number;
    path?: string | undefined;
    code?: string | undefined;
    fileName?: string | undefined;
    size?: number;
    tbName?: string | undefined;
    colName?: string | undefined;
    ref_MasterID?: number | undefined;
    index?: number;
    description?: string | undefined;
    lastModified?: string | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
}

export class FileRecord implements IFileRecord {
    id?: number;
    fileName?: string | undefined;
    fileFormat?: string | undefined;
    filePath?: string | undefined;
    fullPath?: string | undefined;
    contentType?: string | undefined;
    altText?: string | undefined;
    description?: string | undefined;
    message?: string | undefined;
    path?: string | undefined;
    ref_MasterID?: number | undefined;
    ref_Master_str?: string | undefined;
    status?: number | undefined;
    size?: number;
    tbName?: string | undefined;
    colName?: string | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;
    code?: string | undefined;

    constructor(data?: IFileRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileName = _data["fileName"];
            this.fileFormat = _data["fileFormat"];
            this.filePath = _data["filePath"];
            this.fullPath = _data["fullPath"];
            this.contentType = _data["contentType"];
            this.altText = _data["altText"];
            this.description = _data["description"];
            this.message = _data["message"];
            this.path = _data["path"];
            this.ref_MasterID = _data["ref_MasterID"];
            this.ref_Master_str = _data["ref_Master_str"];
            this.status = _data["status"];
            this.size = _data["size"];
            this.tbName = _data["tbName"];
            this.colName = _data["colName"];
            this.approve = _data["approve"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.decentralization = _data["decentralization"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): FileRecord {
        data = typeof data === 'object' ? data : {};
        let result = new FileRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileName"] = this.fileName;
        data["fileFormat"] = this.fileFormat;
        data["filePath"] = this.filePath;
        data["fullPath"] = this.fullPath;
        data["contentType"] = this.contentType;
        data["altText"] = this.altText;
        data["description"] = this.description;
        data["message"] = this.message;
        data["path"] = this.path;
        data["ref_MasterID"] = this.ref_MasterID;
        data["ref_Master_str"] = this.ref_Master_str;
        data["status"] = this.status;
        data["size"] = this.size;
        data["tbName"] = this.tbName;
        data["colName"] = this.colName;
        data["approve"] = this.approve;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["decentralization"] = this.decentralization;
        data["code"] = this.code;
        return data; 
    }

    clone(): FileRecord {
        const json = this.toJSON();
        let result = new FileRecord();
        result.init(json);
        return result;
    }
}

export interface IFileRecord {
    id?: number;
    fileName?: string | undefined;
    fileFormat?: string | undefined;
    filePath?: string | undefined;
    fullPath?: string | undefined;
    contentType?: string | undefined;
    altText?: string | undefined;
    description?: string | undefined;
    message?: string | undefined;
    path?: string | undefined;
    ref_MasterID?: number | undefined;
    ref_Master_str?: string | undefined;
    status?: number | undefined;
    size?: number;
    tbName?: string | undefined;
    colName?: string | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;
    code?: string | undefined;
}

export class SYS_GenRowTable_Detail implements ISYS_GenRowTable_Detail {
    id?: number;
    displaY_STATUS?: number | undefined;
    code?: string | undefined;
    indexRow?: number | undefined;
    columN_NAME?: string | undefined;
    format?: string | undefined;
    userID?: number | undefined;
    possion?: number | undefined;
    namE_VN?: string | undefined;
    namE_EN?: string | undefined;
    name?: string | undefined;
    typE_ID?: number | undefined;
    width?: number | undefined;
    min?: number | undefined;
    max?: number | undefined;
    clasS_INSERT?: string | undefined;
    reference?: string | undefined;
    tablE_NAME?: string | undefined;
    father?: string | undefined;
    decentralization?: string | undefined;
    storeD_PROCEDURES?: string | undefined;
    active?: boolean | undefined;
    shoW_REFERENCE?: boolean | undefined;
    displaY_LIST?: boolean | undefined;
    displaY_EDIT?: boolean | undefined;
    disablE_EDIT?: boolean | undefined;
    alloW_EDIT?: boolean | undefined;
    alloW_SEARCH?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    approve?: boolean | undefined;

    constructor(data?: ISYS_GenRowTable_Detail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displaY_STATUS = _data["displaY_STATUS"];
            this.code = _data["code"];
            this.indexRow = _data["indexRow"];
            this.columN_NAME = _data["columN_NAME"];
            this.format = _data["format"];
            this.userID = _data["userID"];
            this.possion = _data["possion"];
            this.namE_VN = _data["namE_VN"];
            this.namE_EN = _data["namE_EN"];
            this.name = _data["name"];
            this.typE_ID = _data["typE_ID"];
            this.width = _data["width"];
            this.min = _data["min"];
            this.max = _data["max"];
            this.clasS_INSERT = _data["clasS_INSERT"];
            this.reference = _data["reference"];
            this.tablE_NAME = _data["tablE_NAME"];
            this.father = _data["father"];
            this.decentralization = _data["decentralization"];
            this.storeD_PROCEDURES = _data["storeD_PROCEDURES"];
            this.active = _data["active"];
            this.shoW_REFERENCE = _data["shoW_REFERENCE"];
            this.displaY_LIST = _data["displaY_LIST"];
            this.displaY_EDIT = _data["displaY_EDIT"];
            this.disablE_EDIT = _data["disablE_EDIT"];
            this.alloW_EDIT = _data["alloW_EDIT"];
            this.alloW_SEARCH = _data["alloW_SEARCH"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.approve = _data["approve"];
        }
    }

    static fromJS(data: any): SYS_GenRowTable_Detail {
        data = typeof data === 'object' ? data : {};
        let result = new SYS_GenRowTable_Detail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displaY_STATUS"] = this.displaY_STATUS;
        data["code"] = this.code;
        data["indexRow"] = this.indexRow;
        data["columN_NAME"] = this.columN_NAME;
        data["format"] = this.format;
        data["userID"] = this.userID;
        data["possion"] = this.possion;
        data["namE_VN"] = this.namE_VN;
        data["namE_EN"] = this.namE_EN;
        data["name"] = this.name;
        data["typE_ID"] = this.typE_ID;
        data["width"] = this.width;
        data["min"] = this.min;
        data["max"] = this.max;
        data["clasS_INSERT"] = this.clasS_INSERT;
        data["reference"] = this.reference;
        data["tablE_NAME"] = this.tablE_NAME;
        data["father"] = this.father;
        data["decentralization"] = this.decentralization;
        data["storeD_PROCEDURES"] = this.storeD_PROCEDURES;
        data["active"] = this.active;
        data["shoW_REFERENCE"] = this.shoW_REFERENCE;
        data["displaY_LIST"] = this.displaY_LIST;
        data["displaY_EDIT"] = this.displaY_EDIT;
        data["disablE_EDIT"] = this.disablE_EDIT;
        data["alloW_EDIT"] = this.alloW_EDIT;
        data["alloW_SEARCH"] = this.alloW_SEARCH;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["approve"] = this.approve;
        return data; 
    }

    clone(): SYS_GenRowTable_Detail {
        const json = this.toJSON();
        let result = new SYS_GenRowTable_Detail();
        result.init(json);
        return result;
    }
}

export interface ISYS_GenRowTable_Detail {
    id?: number;
    displaY_STATUS?: number | undefined;
    code?: string | undefined;
    indexRow?: number | undefined;
    columN_NAME?: string | undefined;
    format?: string | undefined;
    userID?: number | undefined;
    possion?: number | undefined;
    namE_VN?: string | undefined;
    namE_EN?: string | undefined;
    name?: string | undefined;
    typE_ID?: number | undefined;
    width?: number | undefined;
    min?: number | undefined;
    max?: number | undefined;
    clasS_INSERT?: string | undefined;
    reference?: string | undefined;
    tablE_NAME?: string | undefined;
    father?: string | undefined;
    decentralization?: string | undefined;
    storeD_PROCEDURES?: string | undefined;
    active?: boolean | undefined;
    shoW_REFERENCE?: boolean | undefined;
    displaY_LIST?: boolean | undefined;
    displaY_EDIT?: boolean | undefined;
    disablE_EDIT?: boolean | undefined;
    alloW_EDIT?: boolean | undefined;
    alloW_SEARCH?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    approve?: boolean | undefined;
}

export class SYS_GenRowTable implements ISYS_GenRowTable {
    id?: number;
    code?: string | undefined;
    tablE_NAME?: string | undefined;
    userID?: number | undefined;
    indexRow?: number | undefined;
    namE_VN?: string | undefined;
    namE_EN?: string | undefined;
    name?: string | undefined;
    active?: boolean | undefined;
    iD_DT?: number | undefined;
    displaY_STATUS?: number | undefined;
    codE_DT?: string | undefined;
    columN_NAME?: string | undefined;
    namE_VN_DT?: string | undefined;
    namE_EN_DT?: string | undefined;
    father?: string | undefined;
    decentralizatioN_DT?: string | undefined;
    activE_DT?: boolean | undefined;
    alloW_EDIT?: boolean | undefined;
    decentralization?: string | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    xmL_Detail?: string | undefined;
    approve?: boolean | undefined;
    syS_GenRowTable_Detail?: SYS_GenRowTable_Detail[] | undefined;

    constructor(data?: ISYS_GenRowTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.tablE_NAME = _data["tablE_NAME"];
            this.userID = _data["userID"];
            this.indexRow = _data["indexRow"];
            this.namE_VN = _data["namE_VN"];
            this.namE_EN = _data["namE_EN"];
            this.name = _data["name"];
            this.active = _data["active"];
            this.iD_DT = _data["iD_DT"];
            this.displaY_STATUS = _data["displaY_STATUS"];
            this.codE_DT = _data["codE_DT"];
            this.columN_NAME = _data["columN_NAME"];
            this.namE_VN_DT = _data["namE_VN_DT"];
            this.namE_EN_DT = _data["namE_EN_DT"];
            this.father = _data["father"];
            this.decentralizatioN_DT = _data["decentralizatioN_DT"];
            this.activE_DT = _data["activE_DT"];
            this.alloW_EDIT = _data["alloW_EDIT"];
            this.decentralization = _data["decentralization"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.xmL_Detail = _data["xmL_Detail"];
            this.approve = _data["approve"];
            if (Array.isArray(_data["syS_GenRowTable_Detail"])) {
                this.syS_GenRowTable_Detail = [] as any;
                for (let item of _data["syS_GenRowTable_Detail"])
                    this.syS_GenRowTable_Detail.push(SYS_GenRowTable_Detail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SYS_GenRowTable {
        data = typeof data === 'object' ? data : {};
        let result = new SYS_GenRowTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["tablE_NAME"] = this.tablE_NAME;
        data["userID"] = this.userID;
        data["indexRow"] = this.indexRow;
        data["namE_VN"] = this.namE_VN;
        data["namE_EN"] = this.namE_EN;
        data["name"] = this.name;
        data["active"] = this.active;
        data["iD_DT"] = this.iD_DT;
        data["displaY_STATUS"] = this.displaY_STATUS;
        data["codE_DT"] = this.codE_DT;
        data["columN_NAME"] = this.columN_NAME;
        data["namE_VN_DT"] = this.namE_VN_DT;
        data["namE_EN_DT"] = this.namE_EN_DT;
        data["father"] = this.father;
        data["decentralizatioN_DT"] = this.decentralizatioN_DT;
        data["activE_DT"] = this.activE_DT;
        data["alloW_EDIT"] = this.alloW_EDIT;
        data["decentralization"] = this.decentralization;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["xmL_Detail"] = this.xmL_Detail;
        data["approve"] = this.approve;
        if (Array.isArray(this.syS_GenRowTable_Detail)) {
            data["syS_GenRowTable_Detail"] = [];
            for (let item of this.syS_GenRowTable_Detail)
                data["syS_GenRowTable_Detail"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SYS_GenRowTable {
        const json = this.toJSON();
        let result = new SYS_GenRowTable();
        result.init(json);
        return result;
    }
}

export interface ISYS_GenRowTable {
    id?: number;
    code?: string | undefined;
    tablE_NAME?: string | undefined;
    userID?: number | undefined;
    indexRow?: number | undefined;
    namE_VN?: string | undefined;
    namE_EN?: string | undefined;
    name?: string | undefined;
    active?: boolean | undefined;
    iD_DT?: number | undefined;
    displaY_STATUS?: number | undefined;
    codE_DT?: string | undefined;
    columN_NAME?: string | undefined;
    namE_VN_DT?: string | undefined;
    namE_EN_DT?: string | undefined;
    father?: string | undefined;
    decentralizatioN_DT?: string | undefined;
    activE_DT?: boolean | undefined;
    alloW_EDIT?: boolean | undefined;
    decentralization?: string | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    xmL_Detail?: string | undefined;
    approve?: boolean | undefined;
    syS_GenRowTable_Detail?: SYS_GenRowTable_Detail[] | undefined;
}

export class HRM_Branch_ENTITY implements IHRM_Branch_ENTITY {
    id?: number;
    name?: string | undefined;
    address?: string | undefined;
    lat?: number | undefined;
    long?: number | undefined;

    constructor(data?: IHRM_Branch_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.lat = _data["lat"];
            this.long = _data["long"];
        }
    }

    static fromJS(data: any): HRM_Branch_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HRM_Branch_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["address"] = this.address;
        data["lat"] = this.lat;
        data["long"] = this.long;
        return data; 
    }

    clone(): HRM_Branch_ENTITY {
        const json = this.toJSON();
        let result = new HRM_Branch_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHRM_Branch_ENTITY {
    id?: number;
    name?: string | undefined;
    address?: string | undefined;
    lat?: number | undefined;
    long?: number | undefined;
}

export class HRM_WorkingTime_ENTITY implements IHRM_WorkingTime_ENTITY {
    id?: number;
    hour?: number | undefined;
    name?: string | undefined;
    start?: moment.Moment | undefined;
    end?: moment.Moment | undefined;

    constructor(data?: IHRM_WorkingTime_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.hour = _data["hour"];
            this.name = _data["name"];
            this.start = _data["start"] ? moment.parseZone(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? moment.parseZone(_data["end"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HRM_WorkingTime_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HRM_WorkingTime_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hour"] = this.hour;
        data["name"] = this.name;
        data["start"] = this.start ? this.start.toISOString(true) : <any>undefined;
        data["end"] = this.end ? this.end.toISOString(true) : <any>undefined;
        return data; 
    }

    clone(): HRM_WorkingTime_ENTITY {
        const json = this.toJSON();
        let result = new HRM_WorkingTime_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHRM_WorkingTime_ENTITY {
    id?: number;
    hour?: number | undefined;
    name?: string | undefined;
    start?: moment.Moment | undefined;
    end?: moment.Moment | undefined;
}

export class SYS_Menu_Sub implements ISYS_Menu_Sub {
    id?: number;
    location?: number;
    code?: string | undefined;
    namE_VN?: string | undefined;
    namE_EN?: string | undefined;
    name?: string | undefined;
    userID?: number | undefined;
    active?: boolean | undefined;
    decentralization?: string | undefined;
    icon?: string | undefined;
    link?: string | undefined;
    father?: string | undefined;
    lisT_ACCTIONS?: string | undefined;
    type?: string | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    approve?: boolean | undefined;

    constructor(data?: ISYS_Menu_Sub) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.location = _data["location"];
            this.code = _data["code"];
            this.namE_VN = _data["namE_VN"];
            this.namE_EN = _data["namE_EN"];
            this.name = _data["name"];
            this.userID = _data["userID"];
            this.active = _data["active"];
            this.decentralization = _data["decentralization"];
            this.icon = _data["icon"];
            this.link = _data["link"];
            this.father = _data["father"];
            this.lisT_ACCTIONS = _data["lisT_ACCTIONS"];
            this.type = _data["type"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.approve = _data["approve"];
        }
    }

    static fromJS(data: any): SYS_Menu_Sub {
        data = typeof data === 'object' ? data : {};
        let result = new SYS_Menu_Sub();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["location"] = this.location;
        data["code"] = this.code;
        data["namE_VN"] = this.namE_VN;
        data["namE_EN"] = this.namE_EN;
        data["name"] = this.name;
        data["userID"] = this.userID;
        data["active"] = this.active;
        data["decentralization"] = this.decentralization;
        data["icon"] = this.icon;
        data["link"] = this.link;
        data["father"] = this.father;
        data["lisT_ACCTIONS"] = this.lisT_ACCTIONS;
        data["type"] = this.type;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["approve"] = this.approve;
        return data; 
    }

    clone(): SYS_Menu_Sub {
        const json = this.toJSON();
        let result = new SYS_Menu_Sub();
        result.init(json);
        return result;
    }
}

export interface ISYS_Menu_Sub {
    id?: number;
    location?: number;
    code?: string | undefined;
    namE_VN?: string | undefined;
    namE_EN?: string | undefined;
    name?: string | undefined;
    userID?: number | undefined;
    active?: boolean | undefined;
    decentralization?: string | undefined;
    icon?: string | undefined;
    link?: string | undefined;
    father?: string | undefined;
    lisT_ACCTIONS?: string | undefined;
    type?: string | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    approve?: boolean | undefined;
}

export class SYS_Menu implements ISYS_Menu {
    id?: number;
    location?: number | undefined;
    code?: string | undefined;
    namE_VN?: string | undefined;
    namE_EN?: string | undefined;
    name?: string | undefined;
    active?: boolean | undefined;
    icon?: string | undefined;
    link?: string | undefined;
    xml?: string | undefined;
    userID?: number | undefined;
    lisT_ACCTIONS?: string | undefined;
    syS_Menu_Sub?: SYS_Menu_Sub[] | undefined;
    decentralization?: string | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    approve?: boolean | undefined;

    constructor(data?: ISYS_Menu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.location = _data["location"];
            this.code = _data["code"];
            this.namE_VN = _data["namE_VN"];
            this.namE_EN = _data["namE_EN"];
            this.name = _data["name"];
            this.active = _data["active"];
            this.icon = _data["icon"];
            this.link = _data["link"];
            this.xml = _data["xml"];
            this.userID = _data["userID"];
            this.lisT_ACCTIONS = _data["lisT_ACCTIONS"];
            if (Array.isArray(_data["syS_Menu_Sub"])) {
                this.syS_Menu_Sub = [] as any;
                for (let item of _data["syS_Menu_Sub"])
                    this.syS_Menu_Sub.push(SYS_Menu_Sub.fromJS(item));
            }
            this.decentralization = _data["decentralization"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.approve = _data["approve"];
        }
    }

    static fromJS(data: any): SYS_Menu {
        data = typeof data === 'object' ? data : {};
        let result = new SYS_Menu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["location"] = this.location;
        data["code"] = this.code;
        data["namE_VN"] = this.namE_VN;
        data["namE_EN"] = this.namE_EN;
        data["name"] = this.name;
        data["active"] = this.active;
        data["icon"] = this.icon;
        data["link"] = this.link;
        data["xml"] = this.xml;
        data["userID"] = this.userID;
        data["lisT_ACCTIONS"] = this.lisT_ACCTIONS;
        if (Array.isArray(this.syS_Menu_Sub)) {
            data["syS_Menu_Sub"] = [];
            for (let item of this.syS_Menu_Sub)
                data["syS_Menu_Sub"].push(item.toJSON());
        }
        data["decentralization"] = this.decentralization;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["approve"] = this.approve;
        return data; 
    }

    clone(): SYS_Menu {
        const json = this.toJSON();
        let result = new SYS_Menu();
        result.init(json);
        return result;
    }
}

export interface ISYS_Menu {
    id?: number;
    location?: number | undefined;
    code?: string | undefined;
    namE_VN?: string | undefined;
    namE_EN?: string | undefined;
    name?: string | undefined;
    active?: boolean | undefined;
    icon?: string | undefined;
    link?: string | undefined;
    xml?: string | undefined;
    userID?: number | undefined;
    lisT_ACCTIONS?: string | undefined;
    syS_Menu_Sub?: SYS_Menu_Sub[] | undefined;
    decentralization?: string | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    approve?: boolean | undefined;
}

export class REFERENCE_ENTITY implements IREFERENCE_ENTITY {
    id?: number;
    idEdit?: number | undefined;
    codeFather?: string | undefined;
    userID?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    tablE_NAME?: string | undefined;
    tablE_NAME_DETAIL?: string | undefined;
    stored?: string | undefined;
    param?: string | undefined;
    columN_NAME?: string | undefined;
    values?: string | undefined;
    key?: string | undefined;
    type?: number | undefined;
    inputMasterJSON?: string | undefined;
    modelDetailJSON?: string | undefined;
    outputData?: { [key: string]: any; }[] | undefined;
    genRowTable?: SYS_GenRowTable;

    constructor(data?: IREFERENCE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.idEdit = _data["idEdit"];
            this.codeFather = _data["codeFather"];
            this.userID = _data["userID"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.tablE_NAME = _data["tablE_NAME"];
            this.tablE_NAME_DETAIL = _data["tablE_NAME_DETAIL"];
            this.stored = _data["stored"];
            this.param = _data["param"];
            this.columN_NAME = _data["columN_NAME"];
            this.values = _data["values"];
            this.key = _data["key"];
            this.type = _data["type"];
            this.inputMasterJSON = _data["inputMasterJSON"];
            this.modelDetailJSON = _data["modelDetailJSON"];
            if (Array.isArray(_data["outputData"])) {
                this.outputData = [] as any;
                for (let item of _data["outputData"])
                    this.outputData.push(item);
            }
            this.genRowTable = _data["genRowTable"] ? SYS_GenRowTable.fromJS(_data["genRowTable"]) : <any>undefined;
        }
    }

    static fromJS(data: any): REFERENCE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REFERENCE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["idEdit"] = this.idEdit;
        data["codeFather"] = this.codeFather;
        data["userID"] = this.userID;
        data["code"] = this.code;
        data["name"] = this.name;
        data["tablE_NAME"] = this.tablE_NAME;
        data["tablE_NAME_DETAIL"] = this.tablE_NAME_DETAIL;
        data["stored"] = this.stored;
        data["param"] = this.param;
        data["columN_NAME"] = this.columN_NAME;
        data["values"] = this.values;
        data["key"] = this.key;
        data["type"] = this.type;
        data["inputMasterJSON"] = this.inputMasterJSON;
        data["modelDetailJSON"] = this.modelDetailJSON;
        if (Array.isArray(this.outputData)) {
            data["outputData"] = [];
            for (let item of this.outputData)
                data["outputData"].push(item);
        }
        data["genRowTable"] = this.genRowTable ? this.genRowTable.toJSON() : <any>undefined;
        return data; 
    }

    clone(): REFERENCE_ENTITY {
        const json = this.toJSON();
        let result = new REFERENCE_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IREFERENCE_ENTITY {
    id?: number;
    idEdit?: number | undefined;
    codeFather?: string | undefined;
    userID?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    tablE_NAME?: string | undefined;
    tablE_NAME_DETAIL?: string | undefined;
    stored?: string | undefined;
    param?: string | undefined;
    columN_NAME?: string | undefined;
    values?: string | undefined;
    key?: string | undefined;
    type?: number | undefined;
    inputMasterJSON?: string | undefined;
    modelDetailJSON?: string | undefined;
    outputData?: { [key: string]: any; }[] | undefined;
    genRowTable?: SYS_GenRowTable;
}

export class Chat_ContentModel implements IChat_ContentModel {
    chat_content_id?: string | undefined;
    chat_id?: number;
    user_send?: string | undefined;
    to_user?: string | undefined;
    message_text?: string | undefined;
    message_img?: string | undefined;
    message_file?: string | undefined;
    status?: string | undefined;
    client_avt?: string | undefined;
    arr_img?: string[] | undefined;
    arr_file?: string[] | undefined;
    time_send?: moment.Moment | undefined;
    is_remove?: boolean | undefined;
    is_view?: boolean | undefined;

    constructor(data?: IChat_ContentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chat_content_id = _data["chat_content_id"];
            this.chat_id = _data["chat_id"];
            this.user_send = _data["user_send"];
            this.to_user = _data["to_user"];
            this.message_text = _data["message_text"];
            this.message_img = _data["message_img"];
            this.message_file = _data["message_file"];
            this.status = _data["status"];
            this.client_avt = _data["client_avt"];
            if (Array.isArray(_data["arr_img"])) {
                this.arr_img = [] as any;
                for (let item of _data["arr_img"])
                    this.arr_img.push(item);
            }
            if (Array.isArray(_data["arr_file"])) {
                this.arr_file = [] as any;
                for (let item of _data["arr_file"])
                    this.arr_file.push(item);
            }
            this.time_send = _data["time_send"] ? moment.parseZone(_data["time_send"].toString()) : <any>undefined;
            this.is_remove = _data["is_remove"];
            this.is_view = _data["is_view"];
        }
    }

    static fromJS(data: any): Chat_ContentModel {
        data = typeof data === 'object' ? data : {};
        let result = new Chat_ContentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chat_content_id"] = this.chat_content_id;
        data["chat_id"] = this.chat_id;
        data["user_send"] = this.user_send;
        data["to_user"] = this.to_user;
        data["message_text"] = this.message_text;
        data["message_img"] = this.message_img;
        data["message_file"] = this.message_file;
        data["status"] = this.status;
        data["client_avt"] = this.client_avt;
        if (Array.isArray(this.arr_img)) {
            data["arr_img"] = [];
            for (let item of this.arr_img)
                data["arr_img"].push(item);
        }
        if (Array.isArray(this.arr_file)) {
            data["arr_file"] = [];
            for (let item of this.arr_file)
                data["arr_file"].push(item);
        }
        data["time_send"] = this.time_send ? this.time_send.toISOString(true) : <any>undefined;
        data["is_remove"] = this.is_remove;
        data["is_view"] = this.is_view;
        return data; 
    }

    clone(): Chat_ContentModel {
        const json = this.toJSON();
        let result = new Chat_ContentModel();
        result.init(json);
        return result;
    }
}

export interface IChat_ContentModel {
    chat_content_id?: string | undefined;
    chat_id?: number;
    user_send?: string | undefined;
    to_user?: string | undefined;
    message_text?: string | undefined;
    message_img?: string | undefined;
    message_file?: string | undefined;
    status?: string | undefined;
    client_avt?: string | undefined;
    arr_img?: string[] | undefined;
    arr_file?: string[] | undefined;
    time_send?: moment.Moment | undefined;
    is_remove?: boolean | undefined;
    is_view?: boolean | undefined;
}

export class ChatModel implements IChatModel {
    chat_id?: number;
    new_message?: number | undefined;
    chat_name?: string | undefined;
    user_create?: string | undefined;
    tag?: string | undefined;
    type?: string | undefined;
    list_user?: string | undefined;
    chat_review?: string | undefined;
    my_avt?: string | undefined;
    client_avt?: string | undefined;
    group_avt?: string | undefined;
    user_login?: string | undefined;
    xml?: string | undefined;
    chat_time?: moment.Moment | undefined;
    is_view?: boolean | undefined;
    chat_Content?: Chat_ContentModel[] | undefined;

    constructor(data?: IChatModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chat_id = _data["chat_id"];
            this.new_message = _data["new_message"];
            this.chat_name = _data["chat_name"];
            this.user_create = _data["user_create"];
            this.tag = _data["tag"];
            this.type = _data["type"];
            this.list_user = _data["list_user"];
            this.chat_review = _data["chat_review"];
            this.my_avt = _data["my_avt"];
            this.client_avt = _data["client_avt"];
            this.group_avt = _data["group_avt"];
            this.user_login = _data["user_login"];
            this.xml = _data["xml"];
            this.chat_time = _data["chat_time"] ? moment.parseZone(_data["chat_time"].toString()) : <any>undefined;
            this.is_view = _data["is_view"];
            if (Array.isArray(_data["chat_Content"])) {
                this.chat_Content = [] as any;
                for (let item of _data["chat_Content"])
                    this.chat_Content.push(Chat_ContentModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChatModel {
        data = typeof data === 'object' ? data : {};
        let result = new ChatModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chat_id"] = this.chat_id;
        data["new_message"] = this.new_message;
        data["chat_name"] = this.chat_name;
        data["user_create"] = this.user_create;
        data["tag"] = this.tag;
        data["type"] = this.type;
        data["list_user"] = this.list_user;
        data["chat_review"] = this.chat_review;
        data["my_avt"] = this.my_avt;
        data["client_avt"] = this.client_avt;
        data["group_avt"] = this.group_avt;
        data["user_login"] = this.user_login;
        data["xml"] = this.xml;
        data["chat_time"] = this.chat_time ? this.chat_time.toISOString(true) : <any>undefined;
        data["is_view"] = this.is_view;
        if (Array.isArray(this.chat_Content)) {
            data["chat_Content"] = [];
            for (let item of this.chat_Content)
                data["chat_Content"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ChatModel {
        const json = this.toJSON();
        let result = new ChatModel();
        result.init(json);
        return result;
    }
}

export interface IChatModel {
    chat_id?: number;
    new_message?: number | undefined;
    chat_name?: string | undefined;
    user_create?: string | undefined;
    tag?: string | undefined;
    type?: string | undefined;
    list_user?: string | undefined;
    chat_review?: string | undefined;
    my_avt?: string | undefined;
    client_avt?: string | undefined;
    group_avt?: string | undefined;
    user_login?: string | undefined;
    xml?: string | undefined;
    chat_time?: moment.Moment | undefined;
    is_view?: boolean | undefined;
    chat_Content?: Chat_ContentModel[] | undefined;
}

export class FileModel implements IFileModel {
    id?: number;
    fileName?: string | undefined;
    fileFormat?: string | undefined;
    filePath?: string | undefined;
    fullPath?: string | undefined;
    contentType?: string | undefined;
    altText?: string | undefined;
    description?: string | undefined;
    message?: string | undefined;
    path?: string | undefined;
    ref_MasterID?: number | undefined;
    ref_Master_str?: string | undefined;
    status?: number | undefined;
    size?: number;
    tbName?: string | undefined;
    colName?: string | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;
    code?: string | undefined;

    constructor(data?: IFileModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileName = _data["fileName"];
            this.fileFormat = _data["fileFormat"];
            this.filePath = _data["filePath"];
            this.fullPath = _data["fullPath"];
            this.contentType = _data["contentType"];
            this.altText = _data["altText"];
            this.description = _data["description"];
            this.message = _data["message"];
            this.path = _data["path"];
            this.ref_MasterID = _data["ref_MasterID"];
            this.ref_Master_str = _data["ref_Master_str"];
            this.status = _data["status"];
            this.size = _data["size"];
            this.tbName = _data["tbName"];
            this.colName = _data["colName"];
            this.approve = _data["approve"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.decentralization = _data["decentralization"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): FileModel {
        data = typeof data === 'object' ? data : {};
        let result = new FileModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileName"] = this.fileName;
        data["fileFormat"] = this.fileFormat;
        data["filePath"] = this.filePath;
        data["fullPath"] = this.fullPath;
        data["contentType"] = this.contentType;
        data["altText"] = this.altText;
        data["description"] = this.description;
        data["message"] = this.message;
        data["path"] = this.path;
        data["ref_MasterID"] = this.ref_MasterID;
        data["ref_Master_str"] = this.ref_Master_str;
        data["status"] = this.status;
        data["size"] = this.size;
        data["tbName"] = this.tbName;
        data["colName"] = this.colName;
        data["approve"] = this.approve;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["decentralization"] = this.decentralization;
        data["code"] = this.code;
        return data; 
    }

    clone(): FileModel {
        const json = this.toJSON();
        let result = new FileModel();
        result.init(json);
        return result;
    }
}

export interface IFileModel {
    id?: number;
    fileName?: string | undefined;
    fileFormat?: string | undefined;
    filePath?: string | undefined;
    fullPath?: string | undefined;
    contentType?: string | undefined;
    altText?: string | undefined;
    description?: string | undefined;
    message?: string | undefined;
    path?: string | undefined;
    ref_MasterID?: number | undefined;
    ref_Master_str?: string | undefined;
    status?: number | undefined;
    size?: number;
    tbName?: string | undefined;
    colName?: string | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;
    code?: string | undefined;
}

export class Messenger implements IMessenger {
    id?: string | undefined;
    account_id?: string | undefined;
    account_send?: string | undefined;
    to_user?: string | undefined;
    to_user_last_name?: string | undefined;
    to_user_first_name?: string | undefined;
    message?: string | undefined;
    time_add?: moment.Moment | undefined;
    chat_id?: number;
    message_id?: string | undefined;
    type?: string | undefined;
    tag?: string | undefined;
    message_text?: string | undefined;
    message_new?: number;
    chatModel?: ChatModel;
    message_images?: FileModel[] | undefined;
    message_files?: FileModel[] | undefined;
    is_remove?: boolean | undefined;
    time_remove?: moment.Moment | undefined;
    list_user?: string[] | undefined;

    constructor(data?: IMessenger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.account_id = _data["account_id"];
            this.account_send = _data["account_send"];
            this.to_user = _data["to_user"];
            this.to_user_last_name = _data["to_user_last_name"];
            this.to_user_first_name = _data["to_user_first_name"];
            this.message = _data["message"];
            this.time_add = _data["time_add"] ? moment.parseZone(_data["time_add"].toString()) : <any>undefined;
            this.chat_id = _data["chat_id"];
            this.message_id = _data["message_id"];
            this.type = _data["type"];
            this.tag = _data["tag"];
            this.message_text = _data["message_text"];
            this.message_new = _data["message_new"];
            this.chatModel = _data["chatModel"] ? ChatModel.fromJS(_data["chatModel"]) : <any>undefined;
            if (Array.isArray(_data["message_images"])) {
                this.message_images = [] as any;
                for (let item of _data["message_images"])
                    this.message_images.push(FileModel.fromJS(item));
            }
            if (Array.isArray(_data["message_files"])) {
                this.message_files = [] as any;
                for (let item of _data["message_files"])
                    this.message_files.push(FileModel.fromJS(item));
            }
            this.is_remove = _data["is_remove"];
            this.time_remove = _data["time_remove"] ? moment.parseZone(_data["time_remove"].toString()) : <any>undefined;
            if (Array.isArray(_data["list_user"])) {
                this.list_user = [] as any;
                for (let item of _data["list_user"])
                    this.list_user.push(item);
            }
        }
    }

    static fromJS(data: any): Messenger {
        data = typeof data === 'object' ? data : {};
        let result = new Messenger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["account_id"] = this.account_id;
        data["account_send"] = this.account_send;
        data["to_user"] = this.to_user;
        data["to_user_last_name"] = this.to_user_last_name;
        data["to_user_first_name"] = this.to_user_first_name;
        data["message"] = this.message;
        data["time_add"] = this.time_add ? this.time_add.toISOString(true) : <any>undefined;
        data["chat_id"] = this.chat_id;
        data["message_id"] = this.message_id;
        data["type"] = this.type;
        data["tag"] = this.tag;
        data["message_text"] = this.message_text;
        data["message_new"] = this.message_new;
        data["chatModel"] = this.chatModel ? this.chatModel.toJSON() : <any>undefined;
        if (Array.isArray(this.message_images)) {
            data["message_images"] = [];
            for (let item of this.message_images)
                data["message_images"].push(item.toJSON());
        }
        if (Array.isArray(this.message_files)) {
            data["message_files"] = [];
            for (let item of this.message_files)
                data["message_files"].push(item.toJSON());
        }
        data["is_remove"] = this.is_remove;
        data["time_remove"] = this.time_remove ? this.time_remove.toISOString(true) : <any>undefined;
        if (Array.isArray(this.list_user)) {
            data["list_user"] = [];
            for (let item of this.list_user)
                data["list_user"].push(item);
        }
        return data; 
    }

    clone(): Messenger {
        const json = this.toJSON();
        let result = new Messenger();
        result.init(json);
        return result;
    }
}

export interface IMessenger {
    id?: string | undefined;
    account_id?: string | undefined;
    account_send?: string | undefined;
    to_user?: string | undefined;
    to_user_last_name?: string | undefined;
    to_user_first_name?: string | undefined;
    message?: string | undefined;
    time_add?: moment.Moment | undefined;
    chat_id?: number;
    message_id?: string | undefined;
    type?: string | undefined;
    tag?: string | undefined;
    message_text?: string | undefined;
    message_new?: number;
    chatModel?: ChatModel;
    message_images?: FileModel[] | undefined;
    message_files?: FileModel[] | undefined;
    is_remove?: boolean | undefined;
    time_remove?: moment.Moment | undefined;
    list_user?: string[] | undefined;
}

export class NotificationModel implements INotificationModel {
    id?: number;
    new_message?: number | undefined;
    account_id?: number | undefined;
    top?: number | undefined;
    total?: number | undefined;
    title?: string | undefined;
    message?: string | undefined;
    link_direct?: string | undefined;
    type?: string | undefined;
    string_time?: string | undefined;
    time?: moment.Moment | undefined;
    isView?: boolean | undefined;
    isRead?: boolean | undefined;

    constructor(data?: INotificationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.new_message = _data["new_message"];
            this.account_id = _data["account_id"];
            this.top = _data["top"];
            this.total = _data["total"];
            this.title = _data["title"];
            this.message = _data["message"];
            this.link_direct = _data["link_direct"];
            this.type = _data["type"];
            this.string_time = _data["string_time"];
            this.time = _data["time"] ? moment.parseZone(_data["time"].toString()) : <any>undefined;
            this.isView = _data["isView"];
            this.isRead = _data["isRead"];
        }
    }

    static fromJS(data: any): NotificationModel {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["new_message"] = this.new_message;
        data["account_id"] = this.account_id;
        data["top"] = this.top;
        data["total"] = this.total;
        data["title"] = this.title;
        data["message"] = this.message;
        data["link_direct"] = this.link_direct;
        data["type"] = this.type;
        data["string_time"] = this.string_time;
        data["time"] = this.time ? this.time.toISOString(true) : <any>undefined;
        data["isView"] = this.isView;
        data["isRead"] = this.isRead;
        return data; 
    }

    clone(): NotificationModel {
        const json = this.toJSON();
        let result = new NotificationModel();
        result.init(json);
        return result;
    }
}

export interface INotificationModel {
    id?: number;
    new_message?: number | undefined;
    account_id?: number | undefined;
    top?: number | undefined;
    total?: number | undefined;
    title?: string | undefined;
    message?: string | undefined;
    link_direct?: string | undefined;
    type?: string | undefined;
    string_time?: string | undefined;
    time?: moment.Moment | undefined;
    isView?: boolean | undefined;
    isRead?: boolean | undefined;
}

export class Upload_ENTITY implements IUpload_ENTITY {
    id?: number | undefined;
    path?: string | undefined;
    path_encode?: string | undefined;
    code?: string | undefined;
    fileName?: string | undefined;
    name?: string | undefined;
    size?: number | undefined;
    tbName?: string | undefined;
    column_key?: string | undefined;
    colName?: string | undefined;
    stored?: string | undefined;
    ref_MasterID?: string | undefined;
    ref_master_code?: string | undefined;
    index?: number;
    status?: number | undefined;
    message?: string | undefined;
    description?: string | undefined;
    lastModified?: string | undefined;
    xmL_Data?: string | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;

    constructor(data?: IUpload_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.path = _data["path"];
            this.path_encode = _data["path_encode"];
            this.code = _data["code"];
            this.fileName = _data["fileName"];
            this.name = _data["name"];
            this.size = _data["size"];
            this.tbName = _data["tbName"];
            this.column_key = _data["column_key"];
            this.colName = _data["colName"];
            this.stored = _data["stored"];
            this.ref_MasterID = _data["ref_MasterID"];
            this.ref_master_code = _data["ref_master_code"];
            this.index = _data["index"];
            this.status = _data["status"];
            this.message = _data["message"];
            this.description = _data["description"];
            this.lastModified = _data["lastModified"];
            this.xmL_Data = _data["xmL_Data"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
        }
    }

    static fromJS(data: any): Upload_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new Upload_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["path"] = this.path;
        data["path_encode"] = this.path_encode;
        data["code"] = this.code;
        data["fileName"] = this.fileName;
        data["name"] = this.name;
        data["size"] = this.size;
        data["tbName"] = this.tbName;
        data["column_key"] = this.column_key;
        data["colName"] = this.colName;
        data["stored"] = this.stored;
        data["ref_MasterID"] = this.ref_MasterID;
        data["ref_master_code"] = this.ref_master_code;
        data["index"] = this.index;
        data["status"] = this.status;
        data["message"] = this.message;
        data["description"] = this.description;
        data["lastModified"] = this.lastModified;
        data["xmL_Data"] = this.xmL_Data;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        return data; 
    }

    clone(): Upload_ENTITY {
        const json = this.toJSON();
        let result = new Upload_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IUpload_ENTITY {
    id?: number | undefined;
    path?: string | undefined;
    path_encode?: string | undefined;
    code?: string | undefined;
    fileName?: string | undefined;
    name?: string | undefined;
    size?: number | undefined;
    tbName?: string | undefined;
    column_key?: string | undefined;
    colName?: string | undefined;
    stored?: string | undefined;
    ref_MasterID?: string | undefined;
    ref_master_code?: string | undefined;
    index?: number;
    status?: number | undefined;
    message?: string | undefined;
    description?: string | undefined;
    lastModified?: string | undefined;
    xmL_Data?: string | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
}

export class Tb_TestTheme_Sub1_ENTITY implements ITb_TestTheme_Sub1_ENTITY {
    id?: number;
    col_int?: number | undefined;
    col_char?: string | undefined;
    code?: string | undefined;
    col_LongText?: string | undefined;
    col_Switch?: boolean | undefined;
    col_Date?: moment.Moment | undefined;
    col_Images?: Upload_ENTITY[] | undefined;
    col_meadia?: Upload_ENTITY[] | undefined;
    col_multimedia?: Upload_ENTITY[] | undefined;
    col_datetime?: moment.Moment | undefined;
    col_dateranges?: string | undefined;
    col_time?: moment.Moment | undefined;
    col_Multivalue?: string | undefined;
    col_colorpicker?: string | undefined;
    col_float?: number | undefined;
    col_money?: number | undefined;
    col_content?: string | undefined;
    col_Rating?: number | undefined;
    col_IsOnline?: boolean | undefined;
    col_Engagement?: number | undefined;
    col_Phone?: string | undefined;
    col_Checkbox?: boolean | undefined;
    father?: number | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;

    constructor(data?: ITb_TestTheme_Sub1_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.col_int = _data["col_int"];
            this.col_char = _data["col_char"];
            this.code = _data["code"];
            this.col_LongText = _data["col_LongText"];
            this.col_Switch = _data["col_Switch"];
            this.col_Date = _data["col_Date"] ? moment.parseZone(_data["col_Date"].toString()) : <any>undefined;
            if (Array.isArray(_data["col_Images"])) {
                this.col_Images = [] as any;
                for (let item of _data["col_Images"])
                    this.col_Images.push(Upload_ENTITY.fromJS(item));
            }
            if (Array.isArray(_data["col_meadia"])) {
                this.col_meadia = [] as any;
                for (let item of _data["col_meadia"])
                    this.col_meadia.push(Upload_ENTITY.fromJS(item));
            }
            if (Array.isArray(_data["col_multimedia"])) {
                this.col_multimedia = [] as any;
                for (let item of _data["col_multimedia"])
                    this.col_multimedia.push(Upload_ENTITY.fromJS(item));
            }
            this.col_datetime = _data["col_datetime"] ? moment.parseZone(_data["col_datetime"].toString()) : <any>undefined;
            this.col_dateranges = _data["col_dateranges"];
            this.col_time = _data["col_time"] ? moment.parseZone(_data["col_time"].toString()) : <any>undefined;
            this.col_Multivalue = _data["col_Multivalue"];
            this.col_colorpicker = _data["col_colorpicker"];
            this.col_float = _data["col_float"];
            this.col_money = _data["col_money"];
            this.col_content = _data["col_content"];
            this.col_Rating = _data["col_Rating"];
            this.col_IsOnline = _data["col_IsOnline"];
            this.col_Engagement = _data["col_Engagement"];
            this.col_Phone = _data["col_Phone"];
            this.col_Checkbox = _data["col_Checkbox"];
            this.father = _data["father"];
            this.approve = _data["approve"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.decentralization = _data["decentralization"];
        }
    }

    static fromJS(data: any): Tb_TestTheme_Sub1_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new Tb_TestTheme_Sub1_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["col_int"] = this.col_int;
        data["col_char"] = this.col_char;
        data["code"] = this.code;
        data["col_LongText"] = this.col_LongText;
        data["col_Switch"] = this.col_Switch;
        data["col_Date"] = this.col_Date ? this.col_Date.toISOString(true) : <any>undefined;
        if (Array.isArray(this.col_Images)) {
            data["col_Images"] = [];
            for (let item of this.col_Images)
                data["col_Images"].push(item.toJSON());
        }
        if (Array.isArray(this.col_meadia)) {
            data["col_meadia"] = [];
            for (let item of this.col_meadia)
                data["col_meadia"].push(item.toJSON());
        }
        if (Array.isArray(this.col_multimedia)) {
            data["col_multimedia"] = [];
            for (let item of this.col_multimedia)
                data["col_multimedia"].push(item.toJSON());
        }
        data["col_datetime"] = this.col_datetime ? this.col_datetime.toISOString(true) : <any>undefined;
        data["col_dateranges"] = this.col_dateranges;
        data["col_time"] = this.col_time ? this.col_time.toISOString(true) : <any>undefined;
        data["col_Multivalue"] = this.col_Multivalue;
        data["col_colorpicker"] = this.col_colorpicker;
        data["col_float"] = this.col_float;
        data["col_money"] = this.col_money;
        data["col_content"] = this.col_content;
        data["col_Rating"] = this.col_Rating;
        data["col_IsOnline"] = this.col_IsOnline;
        data["col_Engagement"] = this.col_Engagement;
        data["col_Phone"] = this.col_Phone;
        data["col_Checkbox"] = this.col_Checkbox;
        data["father"] = this.father;
        data["approve"] = this.approve;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["decentralization"] = this.decentralization;
        return data; 
    }

    clone(): Tb_TestTheme_Sub1_ENTITY {
        const json = this.toJSON();
        let result = new Tb_TestTheme_Sub1_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ITb_TestTheme_Sub1_ENTITY {
    id?: number;
    col_int?: number | undefined;
    col_char?: string | undefined;
    code?: string | undefined;
    col_LongText?: string | undefined;
    col_Switch?: boolean | undefined;
    col_Date?: moment.Moment | undefined;
    col_Images?: Upload_ENTITY[] | undefined;
    col_meadia?: Upload_ENTITY[] | undefined;
    col_multimedia?: Upload_ENTITY[] | undefined;
    col_datetime?: moment.Moment | undefined;
    col_dateranges?: string | undefined;
    col_time?: moment.Moment | undefined;
    col_Multivalue?: string | undefined;
    col_colorpicker?: string | undefined;
    col_float?: number | undefined;
    col_money?: number | undefined;
    col_content?: string | undefined;
    col_Rating?: number | undefined;
    col_IsOnline?: boolean | undefined;
    col_Engagement?: number | undefined;
    col_Phone?: string | undefined;
    col_Checkbox?: boolean | undefined;
    father?: number | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;
}

export class Tb_TestTheme_Sub2_ENTITY implements ITb_TestTheme_Sub2_ENTITY {
    id?: number;
    col_int?: number | undefined;
    col_char?: string | undefined;
    code?: string | undefined;
    col_LongText?: string | undefined;
    col_Switch?: boolean | undefined;
    col_Date?: moment.Moment | undefined;
    col_Images?: Upload_ENTITY[] | undefined;
    col_meadia?: Upload_ENTITY[] | undefined;
    col_multimedia?: Upload_ENTITY[] | undefined;
    col_datetime?: moment.Moment | undefined;
    col_dateranges?: string | undefined;
    col_time?: moment.Moment | undefined;
    col_Multivalue?: string | undefined;
    col_colorpicker?: string | undefined;
    col_float?: number | undefined;
    col_money?: number | undefined;
    col_content?: string | undefined;
    col_Rating?: number | undefined;
    col_IsOnline?: boolean | undefined;
    col_Engagement?: number | undefined;
    col_Phone?: string | undefined;
    col_Checkbox?: boolean | undefined;
    father?: number | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;

    constructor(data?: ITb_TestTheme_Sub2_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.col_int = _data["col_int"];
            this.col_char = _data["col_char"];
            this.code = _data["code"];
            this.col_LongText = _data["col_LongText"];
            this.col_Switch = _data["col_Switch"];
            this.col_Date = _data["col_Date"] ? moment.parseZone(_data["col_Date"].toString()) : <any>undefined;
            if (Array.isArray(_data["col_Images"])) {
                this.col_Images = [] as any;
                for (let item of _data["col_Images"])
                    this.col_Images.push(Upload_ENTITY.fromJS(item));
            }
            if (Array.isArray(_data["col_meadia"])) {
                this.col_meadia = [] as any;
                for (let item of _data["col_meadia"])
                    this.col_meadia.push(Upload_ENTITY.fromJS(item));
            }
            if (Array.isArray(_data["col_multimedia"])) {
                this.col_multimedia = [] as any;
                for (let item of _data["col_multimedia"])
                    this.col_multimedia.push(Upload_ENTITY.fromJS(item));
            }
            this.col_datetime = _data["col_datetime"] ? moment.parseZone(_data["col_datetime"].toString()) : <any>undefined;
            this.col_dateranges = _data["col_dateranges"];
            this.col_time = _data["col_time"] ? moment.parseZone(_data["col_time"].toString()) : <any>undefined;
            this.col_Multivalue = _data["col_Multivalue"];
            this.col_colorpicker = _data["col_colorpicker"];
            this.col_float = _data["col_float"];
            this.col_money = _data["col_money"];
            this.col_content = _data["col_content"];
            this.col_Rating = _data["col_Rating"];
            this.col_IsOnline = _data["col_IsOnline"];
            this.col_Engagement = _data["col_Engagement"];
            this.col_Phone = _data["col_Phone"];
            this.col_Checkbox = _data["col_Checkbox"];
            this.father = _data["father"];
            this.approve = _data["approve"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.decentralization = _data["decentralization"];
        }
    }

    static fromJS(data: any): Tb_TestTheme_Sub2_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new Tb_TestTheme_Sub2_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["col_int"] = this.col_int;
        data["col_char"] = this.col_char;
        data["code"] = this.code;
        data["col_LongText"] = this.col_LongText;
        data["col_Switch"] = this.col_Switch;
        data["col_Date"] = this.col_Date ? this.col_Date.toISOString(true) : <any>undefined;
        if (Array.isArray(this.col_Images)) {
            data["col_Images"] = [];
            for (let item of this.col_Images)
                data["col_Images"].push(item.toJSON());
        }
        if (Array.isArray(this.col_meadia)) {
            data["col_meadia"] = [];
            for (let item of this.col_meadia)
                data["col_meadia"].push(item.toJSON());
        }
        if (Array.isArray(this.col_multimedia)) {
            data["col_multimedia"] = [];
            for (let item of this.col_multimedia)
                data["col_multimedia"].push(item.toJSON());
        }
        data["col_datetime"] = this.col_datetime ? this.col_datetime.toISOString(true) : <any>undefined;
        data["col_dateranges"] = this.col_dateranges;
        data["col_time"] = this.col_time ? this.col_time.toISOString(true) : <any>undefined;
        data["col_Multivalue"] = this.col_Multivalue;
        data["col_colorpicker"] = this.col_colorpicker;
        data["col_float"] = this.col_float;
        data["col_money"] = this.col_money;
        data["col_content"] = this.col_content;
        data["col_Rating"] = this.col_Rating;
        data["col_IsOnline"] = this.col_IsOnline;
        data["col_Engagement"] = this.col_Engagement;
        data["col_Phone"] = this.col_Phone;
        data["col_Checkbox"] = this.col_Checkbox;
        data["father"] = this.father;
        data["approve"] = this.approve;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["decentralization"] = this.decentralization;
        return data; 
    }

    clone(): Tb_TestTheme_Sub2_ENTITY {
        const json = this.toJSON();
        let result = new Tb_TestTheme_Sub2_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ITb_TestTheme_Sub2_ENTITY {
    id?: number;
    col_int?: number | undefined;
    col_char?: string | undefined;
    code?: string | undefined;
    col_LongText?: string | undefined;
    col_Switch?: boolean | undefined;
    col_Date?: moment.Moment | undefined;
    col_Images?: Upload_ENTITY[] | undefined;
    col_meadia?: Upload_ENTITY[] | undefined;
    col_multimedia?: Upload_ENTITY[] | undefined;
    col_datetime?: moment.Moment | undefined;
    col_dateranges?: string | undefined;
    col_time?: moment.Moment | undefined;
    col_Multivalue?: string | undefined;
    col_colorpicker?: string | undefined;
    col_float?: number | undefined;
    col_money?: number | undefined;
    col_content?: string | undefined;
    col_Rating?: number | undefined;
    col_IsOnline?: boolean | undefined;
    col_Engagement?: number | undefined;
    col_Phone?: string | undefined;
    col_Checkbox?: boolean | undefined;
    father?: number | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;
}

export class Tb_TestTheme_Sub3_ENTITY implements ITb_TestTheme_Sub3_ENTITY {
    id?: number;
    col_int?: number | undefined;
    col_char?: string | undefined;
    code?: string | undefined;
    col_LongText?: string | undefined;
    col_Switch?: boolean | undefined;
    col_Date?: moment.Moment | undefined;
    col_Images?: Upload_ENTITY[] | undefined;
    col_meadia?: Upload_ENTITY[] | undefined;
    col_multimedia?: Upload_ENTITY[] | undefined;
    col_datetime?: moment.Moment | undefined;
    col_dateranges?: string | undefined;
    col_time?: moment.Moment | undefined;
    col_Multivalue?: string | undefined;
    col_colorpicker?: string | undefined;
    col_float?: number | undefined;
    col_money?: number | undefined;
    col_content?: string | undefined;
    col_Rating?: number | undefined;
    col_IsOnline?: boolean | undefined;
    col_Engagement?: number | undefined;
    col_Phone?: string | undefined;
    col_Checkbox?: boolean | undefined;
    father?: number | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;

    constructor(data?: ITb_TestTheme_Sub3_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.col_int = _data["col_int"];
            this.col_char = _data["col_char"];
            this.code = _data["code"];
            this.col_LongText = _data["col_LongText"];
            this.col_Switch = _data["col_Switch"];
            this.col_Date = _data["col_Date"] ? moment.parseZone(_data["col_Date"].toString()) : <any>undefined;
            if (Array.isArray(_data["col_Images"])) {
                this.col_Images = [] as any;
                for (let item of _data["col_Images"])
                    this.col_Images.push(Upload_ENTITY.fromJS(item));
            }
            if (Array.isArray(_data["col_meadia"])) {
                this.col_meadia = [] as any;
                for (let item of _data["col_meadia"])
                    this.col_meadia.push(Upload_ENTITY.fromJS(item));
            }
            if (Array.isArray(_data["col_multimedia"])) {
                this.col_multimedia = [] as any;
                for (let item of _data["col_multimedia"])
                    this.col_multimedia.push(Upload_ENTITY.fromJS(item));
            }
            this.col_datetime = _data["col_datetime"] ? moment.parseZone(_data["col_datetime"].toString()) : <any>undefined;
            this.col_dateranges = _data["col_dateranges"];
            this.col_time = _data["col_time"] ? moment.parseZone(_data["col_time"].toString()) : <any>undefined;
            this.col_Multivalue = _data["col_Multivalue"];
            this.col_colorpicker = _data["col_colorpicker"];
            this.col_float = _data["col_float"];
            this.col_money = _data["col_money"];
            this.col_content = _data["col_content"];
            this.col_Rating = _data["col_Rating"];
            this.col_IsOnline = _data["col_IsOnline"];
            this.col_Engagement = _data["col_Engagement"];
            this.col_Phone = _data["col_Phone"];
            this.col_Checkbox = _data["col_Checkbox"];
            this.father = _data["father"];
            this.approve = _data["approve"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.decentralization = _data["decentralization"];
        }
    }

    static fromJS(data: any): Tb_TestTheme_Sub3_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new Tb_TestTheme_Sub3_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["col_int"] = this.col_int;
        data["col_char"] = this.col_char;
        data["code"] = this.code;
        data["col_LongText"] = this.col_LongText;
        data["col_Switch"] = this.col_Switch;
        data["col_Date"] = this.col_Date ? this.col_Date.toISOString(true) : <any>undefined;
        if (Array.isArray(this.col_Images)) {
            data["col_Images"] = [];
            for (let item of this.col_Images)
                data["col_Images"].push(item.toJSON());
        }
        if (Array.isArray(this.col_meadia)) {
            data["col_meadia"] = [];
            for (let item of this.col_meadia)
                data["col_meadia"].push(item.toJSON());
        }
        if (Array.isArray(this.col_multimedia)) {
            data["col_multimedia"] = [];
            for (let item of this.col_multimedia)
                data["col_multimedia"].push(item.toJSON());
        }
        data["col_datetime"] = this.col_datetime ? this.col_datetime.toISOString(true) : <any>undefined;
        data["col_dateranges"] = this.col_dateranges;
        data["col_time"] = this.col_time ? this.col_time.toISOString(true) : <any>undefined;
        data["col_Multivalue"] = this.col_Multivalue;
        data["col_colorpicker"] = this.col_colorpicker;
        data["col_float"] = this.col_float;
        data["col_money"] = this.col_money;
        data["col_content"] = this.col_content;
        data["col_Rating"] = this.col_Rating;
        data["col_IsOnline"] = this.col_IsOnline;
        data["col_Engagement"] = this.col_Engagement;
        data["col_Phone"] = this.col_Phone;
        data["col_Checkbox"] = this.col_Checkbox;
        data["father"] = this.father;
        data["approve"] = this.approve;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["decentralization"] = this.decentralization;
        return data; 
    }

    clone(): Tb_TestTheme_Sub3_ENTITY {
        const json = this.toJSON();
        let result = new Tb_TestTheme_Sub3_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ITb_TestTheme_Sub3_ENTITY {
    id?: number;
    col_int?: number | undefined;
    col_char?: string | undefined;
    code?: string | undefined;
    col_LongText?: string | undefined;
    col_Switch?: boolean | undefined;
    col_Date?: moment.Moment | undefined;
    col_Images?: Upload_ENTITY[] | undefined;
    col_meadia?: Upload_ENTITY[] | undefined;
    col_multimedia?: Upload_ENTITY[] | undefined;
    col_datetime?: moment.Moment | undefined;
    col_dateranges?: string | undefined;
    col_time?: moment.Moment | undefined;
    col_Multivalue?: string | undefined;
    col_colorpicker?: string | undefined;
    col_float?: number | undefined;
    col_money?: number | undefined;
    col_content?: string | undefined;
    col_Rating?: number | undefined;
    col_IsOnline?: boolean | undefined;
    col_Engagement?: number | undefined;
    col_Phone?: string | undefined;
    col_Checkbox?: boolean | undefined;
    father?: number | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;
}

export class Tb_TestTheme_ENTITY implements ITb_TestTheme_ENTITY {
    id?: number;
    col_int?: number | undefined;
    col_char?: string | undefined;
    code?: string | undefined;
    col_LongText?: string | undefined;
    col_Switch?: boolean | undefined;
    col_Select?: number | undefined;
    col_Date?: moment.Moment | undefined;
    col_Images?: Upload_ENTITY[] | undefined;
    col_meadia?: Upload_ENTITY[] | undefined;
    col_multimedia?: Upload_ENTITY[] | undefined;
    col_datetime?: moment.Moment | undefined;
    col_dateranges?: string | undefined;
    col_time?: moment.Moment | undefined;
    col_Multivalue?: string | undefined;
    col_colorpicker?: string | undefined;
    col_float?: number | undefined;
    col_money?: number | undefined;
    col_Multirow1?: string | undefined;
    col_Multirow2?: string | undefined;
    col_Multirow3?: string | undefined;
    col_content?: string | undefined;
    col_Rating?: number | undefined;
    col_IsOnline?: boolean | undefined;
    col_Engagement?: number | undefined;
    col_Phone?: string | undefined;
    col_Checkbox?: boolean | undefined;
    col_Autocomplete?: number | undefined;
    xmL_Detail1?: string | undefined;
    xmL_Detail2?: string | undefined;
    xmL_Detail3?: string | undefined;
    tb_TestTheme_Sub1?: Tb_TestTheme_Sub1_ENTITY[] | undefined;
    tb_TestTheme_Sub2?: Tb_TestTheme_Sub2_ENTITY[] | undefined;
    tb_TestTheme_Sub3?: Tb_TestTheme_Sub3_ENTITY[] | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;

    constructor(data?: ITb_TestTheme_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.col_int = _data["col_int"];
            this.col_char = _data["col_char"];
            this.code = _data["code"];
            this.col_LongText = _data["col_LongText"];
            this.col_Switch = _data["col_Switch"];
            this.col_Select = _data["col_Select"];
            this.col_Date = _data["col_Date"] ? moment.parseZone(_data["col_Date"].toString()) : <any>undefined;
            if (Array.isArray(_data["col_Images"])) {
                this.col_Images = [] as any;
                for (let item of _data["col_Images"])
                    this.col_Images.push(Upload_ENTITY.fromJS(item));
            }
            if (Array.isArray(_data["col_meadia"])) {
                this.col_meadia = [] as any;
                for (let item of _data["col_meadia"])
                    this.col_meadia.push(Upload_ENTITY.fromJS(item));
            }
            if (Array.isArray(_data["col_multimedia"])) {
                this.col_multimedia = [] as any;
                for (let item of _data["col_multimedia"])
                    this.col_multimedia.push(Upload_ENTITY.fromJS(item));
            }
            this.col_datetime = _data["col_datetime"] ? moment.parseZone(_data["col_datetime"].toString()) : <any>undefined;
            this.col_dateranges = _data["col_dateranges"];
            this.col_time = _data["col_time"] ? moment.parseZone(_data["col_time"].toString()) : <any>undefined;
            this.col_Multivalue = _data["col_Multivalue"];
            this.col_colorpicker = _data["col_colorpicker"];
            this.col_float = _data["col_float"];
            this.col_money = _data["col_money"];
            this.col_Multirow1 = _data["col_Multirow1"];
            this.col_Multirow2 = _data["col_Multirow2"];
            this.col_Multirow3 = _data["col_Multirow3"];
            this.col_content = _data["col_content"];
            this.col_Rating = _data["col_Rating"];
            this.col_IsOnline = _data["col_IsOnline"];
            this.col_Engagement = _data["col_Engagement"];
            this.col_Phone = _data["col_Phone"];
            this.col_Checkbox = _data["col_Checkbox"];
            this.col_Autocomplete = _data["col_Autocomplete"];
            this.xmL_Detail1 = _data["xmL_Detail1"];
            this.xmL_Detail2 = _data["xmL_Detail2"];
            this.xmL_Detail3 = _data["xmL_Detail3"];
            if (Array.isArray(_data["tb_TestTheme_Sub1"])) {
                this.tb_TestTheme_Sub1 = [] as any;
                for (let item of _data["tb_TestTheme_Sub1"])
                    this.tb_TestTheme_Sub1.push(Tb_TestTheme_Sub1_ENTITY.fromJS(item));
            }
            if (Array.isArray(_data["tb_TestTheme_Sub2"])) {
                this.tb_TestTheme_Sub2 = [] as any;
                for (let item of _data["tb_TestTheme_Sub2"])
                    this.tb_TestTheme_Sub2.push(Tb_TestTheme_Sub2_ENTITY.fromJS(item));
            }
            if (Array.isArray(_data["tb_TestTheme_Sub3"])) {
                this.tb_TestTheme_Sub3 = [] as any;
                for (let item of _data["tb_TestTheme_Sub3"])
                    this.tb_TestTheme_Sub3.push(Tb_TestTheme_Sub3_ENTITY.fromJS(item));
            }
            this.approve = _data["approve"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.decentralization = _data["decentralization"];
        }
    }

    static fromJS(data: any): Tb_TestTheme_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new Tb_TestTheme_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["col_int"] = this.col_int;
        data["col_char"] = this.col_char;
        data["code"] = this.code;
        data["col_LongText"] = this.col_LongText;
        data["col_Switch"] = this.col_Switch;
        data["col_Select"] = this.col_Select;
        data["col_Date"] = this.col_Date ? this.col_Date.toISOString(true) : <any>undefined;
        if (Array.isArray(this.col_Images)) {
            data["col_Images"] = [];
            for (let item of this.col_Images)
                data["col_Images"].push(item.toJSON());
        }
        if (Array.isArray(this.col_meadia)) {
            data["col_meadia"] = [];
            for (let item of this.col_meadia)
                data["col_meadia"].push(item.toJSON());
        }
        if (Array.isArray(this.col_multimedia)) {
            data["col_multimedia"] = [];
            for (let item of this.col_multimedia)
                data["col_multimedia"].push(item.toJSON());
        }
        data["col_datetime"] = this.col_datetime ? this.col_datetime.toISOString(true) : <any>undefined;
        data["col_dateranges"] = this.col_dateranges;
        data["col_time"] = this.col_time ? this.col_time.toISOString(true) : <any>undefined;
        data["col_Multivalue"] = this.col_Multivalue;
        data["col_colorpicker"] = this.col_colorpicker;
        data["col_float"] = this.col_float;
        data["col_money"] = this.col_money;
        data["col_Multirow1"] = this.col_Multirow1;
        data["col_Multirow2"] = this.col_Multirow2;
        data["col_Multirow3"] = this.col_Multirow3;
        data["col_content"] = this.col_content;
        data["col_Rating"] = this.col_Rating;
        data["col_IsOnline"] = this.col_IsOnline;
        data["col_Engagement"] = this.col_Engagement;
        data["col_Phone"] = this.col_Phone;
        data["col_Checkbox"] = this.col_Checkbox;
        data["col_Autocomplete"] = this.col_Autocomplete;
        data["xmL_Detail1"] = this.xmL_Detail1;
        data["xmL_Detail2"] = this.xmL_Detail2;
        data["xmL_Detail3"] = this.xmL_Detail3;
        if (Array.isArray(this.tb_TestTheme_Sub1)) {
            data["tb_TestTheme_Sub1"] = [];
            for (let item of this.tb_TestTheme_Sub1)
                data["tb_TestTheme_Sub1"].push(item.toJSON());
        }
        if (Array.isArray(this.tb_TestTheme_Sub2)) {
            data["tb_TestTheme_Sub2"] = [];
            for (let item of this.tb_TestTheme_Sub2)
                data["tb_TestTheme_Sub2"].push(item.toJSON());
        }
        if (Array.isArray(this.tb_TestTheme_Sub3)) {
            data["tb_TestTheme_Sub3"] = [];
            for (let item of this.tb_TestTheme_Sub3)
                data["tb_TestTheme_Sub3"].push(item.toJSON());
        }
        data["approve"] = this.approve;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["decentralization"] = this.decentralization;
        return data; 
    }

    clone(): Tb_TestTheme_ENTITY {
        const json = this.toJSON();
        let result = new Tb_TestTheme_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ITb_TestTheme_ENTITY {
    id?: number;
    col_int?: number | undefined;
    col_char?: string | undefined;
    code?: string | undefined;
    col_LongText?: string | undefined;
    col_Switch?: boolean | undefined;
    col_Select?: number | undefined;
    col_Date?: moment.Moment | undefined;
    col_Images?: Upload_ENTITY[] | undefined;
    col_meadia?: Upload_ENTITY[] | undefined;
    col_multimedia?: Upload_ENTITY[] | undefined;
    col_datetime?: moment.Moment | undefined;
    col_dateranges?: string | undefined;
    col_time?: moment.Moment | undefined;
    col_Multivalue?: string | undefined;
    col_colorpicker?: string | undefined;
    col_float?: number | undefined;
    col_money?: number | undefined;
    col_Multirow1?: string | undefined;
    col_Multirow2?: string | undefined;
    col_Multirow3?: string | undefined;
    col_content?: string | undefined;
    col_Rating?: number | undefined;
    col_IsOnline?: boolean | undefined;
    col_Engagement?: number | undefined;
    col_Phone?: string | undefined;
    col_Checkbox?: boolean | undefined;
    col_Autocomplete?: number | undefined;
    xmL_Detail1?: string | undefined;
    xmL_Detail2?: string | undefined;
    xmL_Detail3?: string | undefined;
    tb_TestTheme_Sub1?: Tb_TestTheme_Sub1_ENTITY[] | undefined;
    tb_TestTheme_Sub2?: Tb_TestTheme_Sub2_ENTITY[] | undefined;
    tb_TestTheme_Sub3?: Tb_TestTheme_Sub3_ENTITY[] | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;
}

export class HRM_TimeSheet_Detail_ENTITY implements IHRM_TimeSheet_Detail_ENTITY {
    id?: number;
    timeSheet_ID?: number | undefined;
    checkin?: boolean | undefined;
    timeCheckin?: moment.Moment | undefined;
    checkout?: boolean | undefined;
    timeCheckout?: moment.Moment | undefined;
    task_ID?: number | undefined;
    task_Description?: string | undefined;
    notes?: string | undefined;

    constructor(data?: IHRM_TimeSheet_Detail_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.timeSheet_ID = _data["timeSheet_ID"];
            this.checkin = _data["checkin"];
            this.timeCheckin = _data["timeCheckin"] ? moment.parseZone(_data["timeCheckin"].toString()) : <any>undefined;
            this.checkout = _data["checkout"];
            this.timeCheckout = _data["timeCheckout"] ? moment.parseZone(_data["timeCheckout"].toString()) : <any>undefined;
            this.task_ID = _data["task_ID"];
            this.task_Description = _data["task_Description"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): HRM_TimeSheet_Detail_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HRM_TimeSheet_Detail_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["timeSheet_ID"] = this.timeSheet_ID;
        data["checkin"] = this.checkin;
        data["timeCheckin"] = this.timeCheckin ? this.timeCheckin.toISOString(true) : <any>undefined;
        data["checkout"] = this.checkout;
        data["timeCheckout"] = this.timeCheckout ? this.timeCheckout.toISOString(true) : <any>undefined;
        data["task_ID"] = this.task_ID;
        data["task_Description"] = this.task_Description;
        data["notes"] = this.notes;
        return data; 
    }

    clone(): HRM_TimeSheet_Detail_ENTITY {
        const json = this.toJSON();
        let result = new HRM_TimeSheet_Detail_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHRM_TimeSheet_Detail_ENTITY {
    id?: number;
    timeSheet_ID?: number | undefined;
    checkin?: boolean | undefined;
    timeCheckin?: moment.Moment | undefined;
    checkout?: boolean | undefined;
    timeCheckout?: moment.Moment | undefined;
    task_ID?: number | undefined;
    task_Description?: string | undefined;
    notes?: string | undefined;
}

export class HRM_TimeSheet_ENTITY implements IHRM_TimeSheet_ENTITY {
    id?: number | undefined;
    constHour?: number | undefined;
    hourStartMonth?: number | undefined;
    employee_ID?: number | undefined;
    title?: string | undefined;
    start?: number | undefined;
    allday?: number | undefined;
    type_ID?: number | undefined;
    className?: string | undefined;
    hRM_TimeSheet_Details?: HRM_TimeSheet_Detail_ENTITY[] | undefined;
    code?: string | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;

    constructor(data?: IHRM_TimeSheet_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.constHour = _data["constHour"];
            this.hourStartMonth = _data["hourStartMonth"];
            this.employee_ID = _data["employee_ID"];
            this.title = _data["title"];
            this.start = _data["start"];
            this.allday = _data["allday"];
            this.type_ID = _data["type_ID"];
            this.className = _data["className"];
            if (Array.isArray(_data["hRM_TimeSheet_Details"])) {
                this.hRM_TimeSheet_Details = [] as any;
                for (let item of _data["hRM_TimeSheet_Details"])
                    this.hRM_TimeSheet_Details.push(HRM_TimeSheet_Detail_ENTITY.fromJS(item));
            }
            this.code = _data["code"];
            this.approve = _data["approve"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.decentralization = _data["decentralization"];
        }
    }

    static fromJS(data: any): HRM_TimeSheet_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HRM_TimeSheet_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["constHour"] = this.constHour;
        data["hourStartMonth"] = this.hourStartMonth;
        data["employee_ID"] = this.employee_ID;
        data["title"] = this.title;
        data["start"] = this.start;
        data["allday"] = this.allday;
        data["type_ID"] = this.type_ID;
        data["className"] = this.className;
        if (Array.isArray(this.hRM_TimeSheet_Details)) {
            data["hRM_TimeSheet_Details"] = [];
            for (let item of this.hRM_TimeSheet_Details)
                data["hRM_TimeSheet_Details"].push(item.toJSON());
        }
        data["code"] = this.code;
        data["approve"] = this.approve;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["decentralization"] = this.decentralization;
        return data; 
    }

    clone(): HRM_TimeSheet_ENTITY {
        const json = this.toJSON();
        let result = new HRM_TimeSheet_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHRM_TimeSheet_ENTITY {
    id?: number | undefined;
    constHour?: number | undefined;
    hourStartMonth?: number | undefined;
    employee_ID?: number | undefined;
    title?: string | undefined;
    start?: number | undefined;
    allday?: number | undefined;
    type_ID?: number | undefined;
    className?: string | undefined;
    hRM_TimeSheet_Details?: HRM_TimeSheet_Detail_ENTITY[] | undefined;
    code?: string | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;
}

export class CRYPTModel implements ICRYPTModel {
    textEncrypt?: string | undefined;
    textDecrypt?: string | undefined;
    textResult?: string | undefined;
    text?: string | undefined;

    constructor(data?: ICRYPTModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.textEncrypt = _data["textEncrypt"];
            this.textDecrypt = _data["textDecrypt"];
            this.textResult = _data["textResult"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): CRYPTModel {
        data = typeof data === 'object' ? data : {};
        let result = new CRYPTModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["textEncrypt"] = this.textEncrypt;
        data["textDecrypt"] = this.textDecrypt;
        data["textResult"] = this.textResult;
        data["text"] = this.text;
        return data; 
    }

    clone(): CRYPTModel {
        const json = this.toJSON();
        let result = new CRYPTModel();
        result.init(json);
        return result;
    }
}

export interface ICRYPTModel {
    textEncrypt?: string | undefined;
    textDecrypt?: string | undefined;
    textResult?: string | undefined;
    text?: string | undefined;
}

export class HRM_Workspace_Comment_Image_ENTITY implements IHRM_Workspace_Comment_Image_ENTITY {
    id?: number;
    comment_code?: string | undefined;
    image_base64?: string | undefined;
    name?: string | undefined;
    length?: number | undefined;
    code?: string | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;

    constructor(data?: IHRM_Workspace_Comment_Image_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.comment_code = _data["comment_code"];
            this.image_base64 = _data["image_base64"];
            this.name = _data["name"];
            this.length = _data["length"];
            this.code = _data["code"];
            this.approve = _data["approve"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.decentralization = _data["decentralization"];
        }
    }

    static fromJS(data: any): HRM_Workspace_Comment_Image_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HRM_Workspace_Comment_Image_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["comment_code"] = this.comment_code;
        data["image_base64"] = this.image_base64;
        data["name"] = this.name;
        data["length"] = this.length;
        data["code"] = this.code;
        data["approve"] = this.approve;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["decentralization"] = this.decentralization;
        return data; 
    }

    clone(): HRM_Workspace_Comment_Image_ENTITY {
        const json = this.toJSON();
        let result = new HRM_Workspace_Comment_Image_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHRM_Workspace_Comment_Image_ENTITY {
    id?: number;
    comment_code?: string | undefined;
    image_base64?: string | undefined;
    name?: string | undefined;
    length?: number | undefined;
    code?: string | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;
}

export class HRM_Workspace_Comment_Files_ENTITY implements IHRM_Workspace_Comment_Files_ENTITY {
    id?: number;
    comment_code?: string | undefined;
    url_file?: string | undefined;
    name?: string | undefined;
    path?: string | undefined;
    size?: number | undefined;
    description?: string | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    fileName?: string | undefined;
    type_file?: string | undefined;
    length?: number | undefined;
    code?: string | undefined;
    approve?: boolean | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;

    constructor(data?: IHRM_Workspace_Comment_Files_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.comment_code = _data["comment_code"];
            this.url_file = _data["url_file"];
            this.name = _data["name"];
            this.path = _data["path"];
            this.size = _data["size"];
            this.description = _data["description"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.fileName = _data["fileName"];
            this.type_file = _data["type_file"];
            this.length = _data["length"];
            this.code = _data["code"];
            this.approve = _data["approve"];
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.decentralization = _data["decentralization"];
        }
    }

    static fromJS(data: any): HRM_Workspace_Comment_Files_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HRM_Workspace_Comment_Files_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["comment_code"] = this.comment_code;
        data["url_file"] = this.url_file;
        data["name"] = this.name;
        data["path"] = this.path;
        data["size"] = this.size;
        data["description"] = this.description;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["fileName"] = this.fileName;
        data["type_file"] = this.type_file;
        data["length"] = this.length;
        data["code"] = this.code;
        data["approve"] = this.approve;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["decentralization"] = this.decentralization;
        return data; 
    }

    clone(): HRM_Workspace_Comment_Files_ENTITY {
        const json = this.toJSON();
        let result = new HRM_Workspace_Comment_Files_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHRM_Workspace_Comment_Files_ENTITY {
    id?: number;
    comment_code?: string | undefined;
    url_file?: string | undefined;
    name?: string | undefined;
    path?: string | undefined;
    size?: number | undefined;
    description?: string | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    fileName?: string | undefined;
    type_file?: string | undefined;
    length?: number | undefined;
    code?: string | undefined;
    approve?: boolean | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;
}

export class HRM_Workspace_Comment_ENTITY implements IHRM_Workspace_Comment_ENTITY {
    id?: number;
    key_calendar?: string | undefined;
    code?: string | undefined;
    content?: string | undefined;
    account_create?: string | undefined;
    xml_image?: string | undefined;
    percent_done?: number | undefined;
    hrm_workspace_comment_images?: HRM_Workspace_Comment_Image_ENTITY[] | undefined;
    hRM_Workspace_Comment_Files?: HRM_Workspace_Comment_Files_ENTITY[] | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;

    constructor(data?: IHRM_Workspace_Comment_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key_calendar = _data["key_calendar"];
            this.code = _data["code"];
            this.content = _data["content"];
            this.account_create = _data["account_create"];
            this.xml_image = _data["xml_image"];
            this.percent_done = _data["percent_done"];
            if (Array.isArray(_data["hrm_workspace_comment_images"])) {
                this.hrm_workspace_comment_images = [] as any;
                for (let item of _data["hrm_workspace_comment_images"])
                    this.hrm_workspace_comment_images.push(HRM_Workspace_Comment_Image_ENTITY.fromJS(item));
            }
            if (Array.isArray(_data["hRM_Workspace_Comment_Files"])) {
                this.hRM_Workspace_Comment_Files = [] as any;
                for (let item of _data["hRM_Workspace_Comment_Files"])
                    this.hRM_Workspace_Comment_Files.push(HRM_Workspace_Comment_Files_ENTITY.fromJS(item));
            }
            this.approve = _data["approve"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.decentralization = _data["decentralization"];
        }
    }

    static fromJS(data: any): HRM_Workspace_Comment_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HRM_Workspace_Comment_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key_calendar"] = this.key_calendar;
        data["code"] = this.code;
        data["content"] = this.content;
        data["account_create"] = this.account_create;
        data["xml_image"] = this.xml_image;
        data["percent_done"] = this.percent_done;
        if (Array.isArray(this.hrm_workspace_comment_images)) {
            data["hrm_workspace_comment_images"] = [];
            for (let item of this.hrm_workspace_comment_images)
                data["hrm_workspace_comment_images"].push(item.toJSON());
        }
        if (Array.isArray(this.hRM_Workspace_Comment_Files)) {
            data["hRM_Workspace_Comment_Files"] = [];
            for (let item of this.hRM_Workspace_Comment_Files)
                data["hRM_Workspace_Comment_Files"].push(item.toJSON());
        }
        data["approve"] = this.approve;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["decentralization"] = this.decentralization;
        return data; 
    }

    clone(): HRM_Workspace_Comment_ENTITY {
        const json = this.toJSON();
        let result = new HRM_Workspace_Comment_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHRM_Workspace_Comment_ENTITY {
    id?: number;
    key_calendar?: string | undefined;
    code?: string | undefined;
    content?: string | undefined;
    account_create?: string | undefined;
    xml_image?: string | undefined;
    percent_done?: number | undefined;
    hrm_workspace_comment_images?: HRM_Workspace_Comment_Image_ENTITY[] | undefined;
    hRM_Workspace_Comment_Files?: HRM_Workspace_Comment_Files_ENTITY[] | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;
}

export class HRM_Workspace_ENTITY implements IHRM_Workspace_ENTITY {
    id?: number | undefined;
    key?: string | undefined;
    title?: string | undefined;
    start?: moment.Moment | undefined;
    allDay?: boolean | undefined;
    wkName?: string | undefined;
    wkHour?: number | undefined;
    className?: string | undefined;
    idCalendar?: string | undefined;
    idEmployee?: string | undefined;
    idWorkingTime?: string | undefined;
    description?: string | undefined;
    master_id?: string | undefined;
    percent_done?: number | undefined;
    constHour?: number | undefined;
    hRM_TimeSheet_ENTITY?: HRM_TimeSheet_ENTITY;
    hrm_workspace_comment?: HRM_Workspace_Comment_ENTITY[] | undefined;
    html_comment?: string | undefined;
    color?: string | undefined;
    total_comment_load?: number | undefined;
    xml_comment?: string | undefined;
    code?: string | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;

    constructor(data?: IHRM_Workspace_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.title = _data["title"];
            this.start = _data["start"] ? moment.parseZone(_data["start"].toString()) : <any>undefined;
            this.allDay = _data["allDay"];
            this.wkName = _data["wkName"];
            this.wkHour = _data["wkHour"];
            this.className = _data["className"];
            this.idCalendar = _data["idCalendar"];
            this.idEmployee = _data["idEmployee"];
            this.idWorkingTime = _data["idWorkingTime"];
            this.description = _data["description"];
            this.master_id = _data["master_id"];
            this.percent_done = _data["percent_done"];
            this.constHour = _data["constHour"];
            this.hRM_TimeSheet_ENTITY = _data["hRM_TimeSheet_ENTITY"] ? HRM_TimeSheet_ENTITY.fromJS(_data["hRM_TimeSheet_ENTITY"]) : <any>undefined;
            if (Array.isArray(_data["hrm_workspace_comment"])) {
                this.hrm_workspace_comment = [] as any;
                for (let item of _data["hrm_workspace_comment"])
                    this.hrm_workspace_comment.push(HRM_Workspace_Comment_ENTITY.fromJS(item));
            }
            this.html_comment = _data["html_comment"];
            this.color = _data["color"];
            this.total_comment_load = _data["total_comment_load"];
            this.xml_comment = _data["xml_comment"];
            this.code = _data["code"];
            this.approve = _data["approve"];
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.decentralization = _data["decentralization"];
        }
    }

    static fromJS(data: any): HRM_Workspace_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HRM_Workspace_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["title"] = this.title;
        data["start"] = this.start ? this.start.toISOString(true) : <any>undefined;
        data["allDay"] = this.allDay;
        data["wkName"] = this.wkName;
        data["wkHour"] = this.wkHour;
        data["className"] = this.className;
        data["idCalendar"] = this.idCalendar;
        data["idEmployee"] = this.idEmployee;
        data["idWorkingTime"] = this.idWorkingTime;
        data["description"] = this.description;
        data["master_id"] = this.master_id;
        data["percent_done"] = this.percent_done;
        data["constHour"] = this.constHour;
        data["hRM_TimeSheet_ENTITY"] = this.hRM_TimeSheet_ENTITY ? this.hRM_TimeSheet_ENTITY.toJSON() : <any>undefined;
        if (Array.isArray(this.hrm_workspace_comment)) {
            data["hrm_workspace_comment"] = [];
            for (let item of this.hrm_workspace_comment)
                data["hrm_workspace_comment"].push(item.toJSON());
        }
        data["html_comment"] = this.html_comment;
        data["color"] = this.color;
        data["total_comment_load"] = this.total_comment_load;
        data["xml_comment"] = this.xml_comment;
        data["code"] = this.code;
        data["approve"] = this.approve;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["decentralization"] = this.decentralization;
        return data; 
    }

    clone(): HRM_Workspace_ENTITY {
        const json = this.toJSON();
        let result = new HRM_Workspace_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHRM_Workspace_ENTITY {
    id?: number | undefined;
    key?: string | undefined;
    title?: string | undefined;
    start?: moment.Moment | undefined;
    allDay?: boolean | undefined;
    wkName?: string | undefined;
    wkHour?: number | undefined;
    className?: string | undefined;
    idCalendar?: string | undefined;
    idEmployee?: string | undefined;
    idWorkingTime?: string | undefined;
    description?: string | undefined;
    master_id?: string | undefined;
    percent_done?: number | undefined;
    constHour?: number | undefined;
    hRM_TimeSheet_ENTITY?: HRM_TimeSheet_ENTITY;
    hrm_workspace_comment?: HRM_Workspace_Comment_ENTITY[] | undefined;
    html_comment?: string | undefined;
    color?: string | undefined;
    total_comment_load?: number | undefined;
    xml_comment?: string | undefined;
    code?: string | undefined;
    approve?: boolean | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;
}

export class HRM_Workspace_Master_ENTITY implements IHRM_Workspace_Master_ENTITY {
    key?: string | undefined;
    hRM_Workspace?: HRM_Workspace_ENTITY[] | undefined;
    xmL_Workspace?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    type?: string | undefined;
    check_in?: number | undefined;
    check_out?: number | undefined;
    timesheet_early?: number | undefined;
    late_timesheet?: number | undefined;
    day_off?: number | undefined;
    indexRow?: number | undefined;
    approve?: boolean | undefined;
    data_month?: moment.Moment | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;

    constructor(data?: IHRM_Workspace_Master_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            if (Array.isArray(_data["hRM_Workspace"])) {
                this.hRM_Workspace = [] as any;
                for (let item of _data["hRM_Workspace"])
                    this.hRM_Workspace.push(HRM_Workspace_ENTITY.fromJS(item));
            }
            this.xmL_Workspace = _data["xmL_Workspace"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.type = _data["type"];
            this.check_in = _data["check_in"];
            this.check_out = _data["check_out"];
            this.timesheet_early = _data["timesheet_early"];
            this.late_timesheet = _data["late_timesheet"];
            this.day_off = _data["day_off"];
            this.indexRow = _data["indexRow"];
            this.approve = _data["approve"];
            this.data_month = _data["data_month"] ? moment.parseZone(_data["data_month"].toString()) : <any>undefined;
            this.datE_ADD = _data["datE_ADD"] ? moment.parseZone(_data["datE_ADD"].toString()) : <any>undefined;
            this.datE_EDIT = _data["datE_EDIT"] ? moment.parseZone(_data["datE_EDIT"].toString()) : <any>undefined;
            this.accounT_ID = _data["accounT_ID"];
            this.notes = _data["notes"];
            this.decentralization = _data["decentralization"];
        }
    }

    static fromJS(data: any): HRM_Workspace_Master_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HRM_Workspace_Master_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        if (Array.isArray(this.hRM_Workspace)) {
            data["hRM_Workspace"] = [];
            for (let item of this.hRM_Workspace)
                data["hRM_Workspace"].push(item.toJSON());
        }
        data["xmL_Workspace"] = this.xmL_Workspace;
        data["name"] = this.name;
        data["code"] = this.code;
        data["type"] = this.type;
        data["check_in"] = this.check_in;
        data["check_out"] = this.check_out;
        data["timesheet_early"] = this.timesheet_early;
        data["late_timesheet"] = this.late_timesheet;
        data["day_off"] = this.day_off;
        data["indexRow"] = this.indexRow;
        data["approve"] = this.approve;
        data["data_month"] = this.data_month ? this.data_month.toISOString(true) : <any>undefined;
        data["datE_ADD"] = this.datE_ADD ? this.datE_ADD.toISOString(true) : <any>undefined;
        data["datE_EDIT"] = this.datE_EDIT ? this.datE_EDIT.toISOString(true) : <any>undefined;
        data["accounT_ID"] = this.accounT_ID;
        data["notes"] = this.notes;
        data["decentralization"] = this.decentralization;
        return data; 
    }

    clone(): HRM_Workspace_Master_ENTITY {
        const json = this.toJSON();
        let result = new HRM_Workspace_Master_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHRM_Workspace_Master_ENTITY {
    key?: string | undefined;
    hRM_Workspace?: HRM_Workspace_ENTITY[] | undefined;
    xmL_Workspace?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    type?: string | undefined;
    check_in?: number | undefined;
    check_out?: number | undefined;
    timesheet_early?: number | undefined;
    late_timesheet?: number | undefined;
    day_off?: number | undefined;
    indexRow?: number | undefined;
    approve?: boolean | undefined;
    data_month?: moment.Moment | undefined;
    datE_ADD?: moment.Moment | undefined;
    datE_EDIT?: moment.Moment | undefined;
    accounT_ID?: number | undefined;
    notes?: string | undefined;
    decentralization?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

let dataUploads: any[] = [];